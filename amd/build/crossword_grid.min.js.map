{"version":3,"file":"crossword_grid.min.js","sources":["../src/crossword_grid.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * CrosswordGrid class handle every function relative to grid.\n *\n * @module qtype_crossword/crossword_grid\n * @copyright 2022 The Open University\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {CrosswordQuestion} from 'qtype_crossword/crossword_question';\nimport {CrosswordClue} from './crossword_clue';\n\nexport class CrosswordGrid extends CrosswordQuestion {\n\n    /**\n     * Constructor.\n     *\n     * @param {Object} options The settings for crossword.\n     */\n    constructor(options) {\n        super(options);\n    }\n\n    /**\n     * Build the background table.\n     */\n    buildBackgroundTable() {\n        let {colsNum, rowsNum, previewSetting} = this.options;\n        let style = previewSetting;\n\n        // Create table element.\n        const tableEl = document.createElement('table');\n\n        // Preview mode will add one more columns and row to add the coordinate helper.\n        colsNum++;\n        rowsNum++;\n\n        tableEl.className = 'crossword-grid';\n        // Set the background color.\n        tableEl.style.backgroundColor = style.backgroundColor;\n\n        for (let i = 0; i < rowsNum; i++) {\n            const rowEl = document.createElement('tr');\n            rowEl.className = 'grid-row';\n            for (let j = 0; j < colsNum; j++) {\n                // Create square.\n                let squareEl = document.createElement('td');\n                squareEl.className = 'grid-square';\n                squareEl.style.borderColor = style.borderColor;\n                squareEl.style.color = style.color;\n\n                if (i === 0 && j === 0) {\n                    squareEl.classList.add('cell-white');\n                }\n\n                // Adding alphanumeric.\n                if (i === 0 && j !== 0) {\n                    squareEl.innerText = this.getColumnLabel(j - 1);\n                    squareEl.classList.add('square-indicate-horizontal');\n                }\n                if (i !== 0 && j === 0) {\n                    squareEl.innerText = i;\n                    squareEl.classList.add('square-indicate-vertical');\n                }\n                rowEl.append(squareEl);\n            }\n            tableEl.append(rowEl);\n        }\n        this.tableEl = tableEl;\n        this.options.crosswordEl.innerHTML = tableEl.outerHTML;\n    }\n\n    /**\n     * Add each cell into table.\n     */\n    addCell() {\n        let {words, previewSetting, rowsNum, colsNum, crosswordEl} = this.options;\n        let labelPlaceholder = crosswordEl.dataset.label;\n        const orientationMarks = ['→', '↓'];\n        // Don't draw empty words.\n        if (words.length === 0) {\n            return;\n        }\n        for (let i = 0; i < words.length; i++) {\n            const answer = words[i].answer.trim().replace(/-|\\s/g, '');\n            let row = words[i].startrow + 1;\n            let column = words[i].startcolumn + 1;\n            let answerLength = answer.length;\n            let realLength = answerLength + words[i].startcolumn;\n            let allowLength = parseInt(colsNum);\n            // Add more columns and row for preview.\n            row++;\n            column++;\n\n            if (words[i].orientation) {\n                realLength = answerLength + words[i].startrow;\n                allowLength = parseInt(rowsNum);\n            }\n\n            for (let j = 0; j < answer.length; j++) {\n                const number = i + 1;\n                let isInvalidLetter = false;\n                const squareEl = document.querySelector('.grid-row:nth-child(' + row + ') .grid-square:nth-child(' + column + ')');\n                if (!squareEl) {\n                    continue;\n                }\n\n                // Paint white background.\n                squareEl.classList.add('background-white');\n\n                if (j === 0) {\n                    const labelEl = squareEl.querySelector('.word-label');\n                    const labelParams = {\n                        number: words[i]?.no ?? number,\n                        orientation: orientationMarks[words[i].orientation],\n                    };\n                    let labelText = labelPlaceholder;\n                    for (let index in labelParams) {\n                        labelText = labelText.replace(`{${index}}`, labelParams[index]);\n                    }\n                    if (!labelEl) {\n                        let spanEl = document.createElement('span');\n                        spanEl.className = 'word-label text-left';\n                        spanEl.innerText = labelText;\n                        squareEl.append(spanEl);\n                    } else {\n                        let label = labelEl.innerText;\n                        isInvalidLetter = label.includes(orientationMarks[words[i].orientation]);\n                        label += ', ' + labelText;\n                        labelEl.innerText = label;\n                    }\n                }\n                const letter = answer[j].toUpperCase().trim() ?? '';\n                const contentEl = squareEl.querySelector('span.word-content');\n                if (!isInvalidLetter) {\n                    isInvalidLetter = this.isContainSpecialCharacters(letter);\n                }\n                if (!contentEl) {\n                    let spanEl = document.createElement('span');\n                    spanEl.className = 'word-content';\n                    spanEl.innerText = letter;\n                    squareEl.append(spanEl);\n                } else {\n                    let text = '';\n                    const innerText = contentEl.innerText;\n                    if (innerText.search(letter) < 0) {\n                        isInvalidLetter = true;\n                        text = innerText + ' | ' + letter;\n                        contentEl.innerText = text;\n                    }\n                }\n\n                if (realLength > allowLength || isInvalidLetter) {\n                    squareEl.style.backgroundColor = previewSetting.conflictColor;\n                }\n\n                if (words[i].orientation) {\n                    row++;\n                } else {\n                    column++;\n                }\n            }\n        }\n    }\n\n    /**\n     * Show the crossword preview.\n     */\n    previewCrossword() {\n        // Build the background table.\n        this.buildBackgroundTable();\n        // Fill the cell into the table.\n        this.addCell();\n    }\n\n    /**\n     * Build crossword for attempt.\n     */\n    buildCrossword() {\n        const options = this.options;\n        // Setup size of crossword.\n        this.options = {...options, width: options.colsNum * 31, height: options.rowsNum * 31};\n        // Set up for clue input: maxlength, aria-label.\n        const crosswordClue = new CrosswordClue(this.options);\n        crosswordClue.setUpClue();\n        // Draw crossword by SVG to support high contrast mode.\n        this.drawCrosswordSVG();\n        // Sync data between clue section and crossword cell.\n        this.syncDataForInit();\n        // Add event when resized screen.\n        this.addEventResizeScreen();\n    }\n\n    /**\n     * Draw crossword by SVG element.\n     */\n    drawCrosswordSVG() {\n        const options = this.options;\n        const crosswordEl = this.options.crosswordEl;\n\n        if (!crosswordEl) {\n            return;\n        }\n\n        // Create background.\n        let svg = this.createElementNSFrom(\n            'svg',\n            {\n                'class': 'crossword-grid',\n                viewBox: `0 0 ${options.width} ${options.height}`\n            }\n        );\n\n        // Create black background.\n        const rectEl = this.createElementNSFrom(\n            'rect',\n            {\n                'class': 'crossword-grid-background',\n                x: 0,\n                y: 0,\n                width: options.width,\n                height: options.height\n            }\n        );\n        svg.append(rectEl);\n\n        // Create svg body.\n        svg = this.createCrosswordBody(svg);\n\n        // Set size for crossword.\n        svg = this.setSizeForCrossword(svg);\n\n        // Add horizontal and vertical line.\n        svg = this.setBorder(svg);\n        // Create an input, by default, it will be hidden.\n        const inputContainEl = this.createElementFrom(\n            'div',\n            {\n                'class': 'crossword-hidden-input-wrapper'\n            }\n        );\n        const inputEl = this.createElementFrom(\n            'input',\n            {\n                type: 'text',\n                'class': 'crossword-hidden-input',\n                maxlength: 1,\n                autocomplete: 'off',\n                spellcheck: false,\n                autocorrect: 'off'\n            }\n        );\n        // Add event for word input.\n        this.addEventForWordInput(inputEl);\n        inputContainEl.append(inputEl);\n\n        if (options.colsNum >= 15) {\n            svg.classList.add('adjust-small-crossword');\n        }\n\n        if (options.colsNum >= 20) {\n            svg.classList.add('adjust-crossword');\n        }\n        crosswordEl.append(svg, inputContainEl);\n    }\n\n    /**\n     * Creates an element with the specified namespace URI and qualified name.\n     *\n     * @param {String} type\n     * @param {Object} attributes\n     *\n     * @return {Element} The return element.\n     */\n    createElementNSFrom(type, attributes = {}) {\n        const element = document.createElementNS('http://www.w3.org/2000/svg', type);\n        for (let key in attributes) {\n            element.setAttributeNS(null, key, attributes[key]);\n        }\n        return element;\n    }\n\n    /**\n     * Create element with attributes.\n     *\n     * @param {String} type\n     * @param {Object} attributes The attribute list.\n     * @return {Element} The return element.\n     */\n    createElementFrom(type, attributes = {}) {\n        const element = document.createElement(type);\n        for (let key in attributes) {\n            element.setAttribute(key, attributes[key]);\n        }\n        return element;\n    }\n\n    /**\n     * Calculate position and add cell into the crossword.\n     *\n     * @param {Element} svg  The svg element.\n     * @return {Element} The svg element.\n     */\n    createCrosswordBody(svg) {\n        const {words, cellWidth, cellHeight} = this.options;\n        let count = 0;\n        for (let i in words) {\n            const word = words[i];\n            const ignoreList = this.getIgnoreIndexByAnswerNumber(word.number);\n            for (let key = 0; key < word.length - ignoreList.length; key++) {\n                // Prepare attributes for g.\n                const customAttribute = {\n                    'data-startrow': word.startRow,\n                    'data-startcolumn': word.startColumn,\n                    'data-letterindex': key,\n                    'data-word': '(' + word.number + ')',\n                    'data-code': 'A' + count\n                };\n                // Calculate the letter position.\n                const position = this.calculatePosition(word, parseInt(key));\n                // Create rect element with these position.\n                const rectEl = this.createElementNSFrom(\n                    'rect',\n                    {\n                        ...position,\n                        width: cellWidth,\n                        height: cellHeight,\n                        'class': 'crossword-cell'\n                    }\n                );\n                // Create g element with the attributes.\n                let g = this.createElementNSFrom('g', {...customAttribute});\n                // Get exist ting rect element.\n                const existingRectElement = svg.querySelector(`rect.crossword-cell[x='${position.x}'][y='${position.y}']`);\n                // Create text element to hold the letter.\n                const textEl = this.createElementNSFrom(\n                    'text',\n                    {\n                        'class': 'crossword-cell-text',\n                        x: position.x + cellWidth / 2,\n                        y: position.y + cellHeight / 2 + 1,\n                        'text-anchor': 'middle',\n                        'alignment-baseline': 'middle',\n                    }\n                );\n                // Check if cell is not drawn.\n                if (!existingRectElement) {\n                    // Create cell.\n                    g.append(rectEl);\n                    // If it's the first cell of word.\n                    // Draw word number.\n                    if (parseInt(key) === 0) {\n                        g = this.appendCellNumber(g, position, word.wordNumber);\n                    }\n                    g.append(textEl);\n                    // Add event for cell.\n                    this.addEventForG(g);\n                    count++;\n                    svg.append(g);\n                } else {\n                    let existingNumberElement = existingRectElement.closest('g').querySelector('text.crossword-cell-number');\n                    let currentWord = existingRectElement.closest('g').dataset.word;\n                    let g;\n                    existingRectElement.closest('g').dataset.word = currentWord + '(' + word.number + ')';\n                    if (parseInt(key) !== 0) {\n                        continue;\n                    }\n                    if (!existingNumberElement) {\n                        // Create new word number.\n                        g = existingRectElement.closest('g');\n                        this.appendCellNumber(g, position, word.wordNumber);\n                    }\n                }\n            }\n        }\n        return svg;\n    }\n\n    /**\n     * Set horizontal and vertical line for grid.\n     *\n     * @param {Element} svg The svg element.\n     * @return {Element} The svg element after appended border.\n     */\n    setBorder(svg) {\n        const {colsNum, rowsNum, cellWidth, cellHeight, width, height} = this.options;\n\n        for (let i = 0; i <= rowsNum; i++) {\n            let strokeWidth = 1;\n            if (i === 0 || i === rowsNum) {\n                strokeWidth = 2;\n            }\n            const horizontalLine = this.createElementNSFrom('line', {\n                x1: 0,\n                y1: i * cellHeight,\n                x2: width,\n                y2: i * cellHeight,\n                stroke: '#000',\n                'stroke-width': strokeWidth,\n            });\n            svg.appendChild(horizontalLine);\n        }\n\n        for (let i = 0; i <= colsNum; i++) {\n            let strokeWidth = 1;\n            if (i === 0 || i === colsNum) {\n                strokeWidth = 2;\n            }\n            const verticalLine = this.createElementNSFrom('line', {\n                x1: i * cellWidth,\n                y1: 0,\n                x2: i * cellWidth,\n                y2: height,\n                stroke: '#000',\n                'stroke-width': strokeWidth,\n            });\n            svg.appendChild(verticalLine);\n        }\n\n        return svg;\n    }\n\n    /**\n     * Create word number for the cell.\n     *\n     * @param {Element} g The g element.\n     * @param {Object} position The coordinates of letter.\n     * @param {Number} wordNumber The word number.\n     *\n     * @return {Element} The g element.\n     */\n    appendCellNumber(g, position, wordNumber) {\n        // Update position.\n        const x = position.x + 2;\n        const y = position.y + 10;\n        let textNumber = this.createElementNSFrom(\n            'text',\n            {\n                x,\n                y,\n                'class': 'crossword-cell-number'\n            }\n        );\n        textNumber.append(wordNumber);\n        g.append(textNumber);\n        return g;\n    }\n\n    /**\n     * Add event to the g element.\n     *\n     * @param {Element} g The g element.\n     */\n    addEventForG(g) {\n        const {readonly} = this.options;\n        if (readonly) {\n            return;\n        }\n        // Handle event click.\n        g.addEventListener('click', (e) => {\n            const inputWrapperEl = this.options.crosswordEl.querySelector('.crossword-hidden-input-wrapper');\n            const inputEl = inputWrapperEl.querySelector('input');\n            let element = e.target;\n            // Make sure select g.\n            if (element.tagName !== 'g') {\n                element = element.closest('g');\n            }\n            this.handleWordSelect(element);\n            inputEl.dataset.code = element.dataset.code;\n            inputEl.value = '';\n            this.updatePositionForCellInput(element.querySelector('rect'));\n            inputEl.focus();\n        });\n    }\n\n    /**\n     * Handle action when click on cell.\n     *\n     * @param {Element} gEl The g element.\n     */\n    handleWordSelect(gEl) {\n        const currentCell = gEl.dataset.code;\n        let words = gEl.dataset.word;\n        let focus = -1;\n        let {coordinates, wordNumber} = this.options;\n\n        // Detect word number.\n        words = words.match(/(\\d+)/g);\n\n        // Detect word number based on event click.\n        // The focus variable is the new word number.\n        if (currentCell === coordinates) {\n            const indexCell = words.indexOf(wordNumber);\n            if (words[indexCell + 1] !== undefined) {\n                focus = words[indexCell + 1];\n            } else {\n                focus = words[0];\n            }\n        } else {\n            // Update new coordinates.\n            this.options.coordinates = currentCell;\n            if (wordNumber < 0) {\n                this.options.wordNumber = words[0];\n            }\n            if (words.includes(wordNumber)) {\n                focus = wordNumber;\n            } else {\n                focus = words[0];\n            }\n        }\n        // Update word number.\n        this.options.wordNumber = focus;\n        const word = this.options.words.find(o => o.number === parseInt(focus));\n        if (!word) {\n            return;\n        }\n        // Sorting and Updating letter index.\n        this.updateLetterIndexForCells(word);\n        // Toggle highlight and focused.\n        this.toggleHighlight(word, gEl);\n        // Focus the clue.\n        this.focusClue();\n        // Update sticky clue for mobile version.\n        this.setStickyClue();\n    }\n\n    /**\n     * Set size and position for cell input.\n     *\n     * @param {Element} [rectEl=null] Rect element.\n     */\n    updatePositionForCellInput(rectEl = null) {\n        if (rectEl === null) {\n            rectEl = this.options.crosswordEl.querySelector('rect.crossword-cell-focussed');\n        }\n        if (rectEl) {\n            const rect = rectEl.getBoundingClientRect();\n            const parentEl = this.options.crosswordEl.querySelector('.crossword-grid').getBoundingClientRect();\n            const inputWrapperEl = this.options.crosswordEl.querySelector('.crossword-hidden-input-wrapper');\n            let top = rect.top - parentEl.top;\n            if (top < 1) {\n                top = 0;\n            }\n            inputWrapperEl.style.cssText = `\n                display: block; top: ${top + 2}px;\n                left: ${rect.left - parentEl.left + 2}px;\n                width: ${rect.width - 3}px;\n                height: ${rect.height - 3}px\n            `;\n        }\n    }\n\n    /**\n     * Handle insert text event (for keyboard and non-keyboard events).\n     *\n     * @param {Object} event Event data.\n     * @param {String} value the character we are inserted to the clue grid.\n     */\n    handleInsertTextEventForGridInput(event, value) {\n        const {wordNumber, words} = this.options;\n        const inputEl = event.target;\n        let code = inputEl.dataset.code;\n        const upperText = value.toUpperCase();\n        if (this.replaceText(value) === '') {\n            return;\n        }\n        // If a letter is entered using an IME keyboard, it may contain multiple characters.\n        // Therefore, we need to split it into an array and loop through it to handle each character.\n        let chars = upperText.split('');\n        let letterIndex;\n        const wordObj = words.find(word => word.number === parseInt(wordNumber));\n        for (let char of chars) {\n            // Find the text element in the g element based on the code.\n            const textEl = this.options.crosswordEl.querySelector(`g[data-code='${code}'] text.crossword-cell-text`);\n            if (!textEl || this.replaceText(char) === '') {\n                continue;\n            }\n            // Set character into text element in grid.\n            textEl.innerHTML = char;\n            if (!letterIndex) {\n                // Set the letter index based on the text element for the first time.\n                letterIndex = parseInt(textEl.closest('g').dataset.letterindex);\n            }\n            // When the answer contains special characters, the next `charIndex` will not be equal to `letterIndex + 1`.\n            // For example, if the answer is \"A-B-C\", when attempting to display the answer in the clue input,\n            // it will be shown as \"_ - _ - _\", the letter index will be 0(A), 1(-), 2(B), 3(-), 4(C),\n            // but in the grid, only three cells will be shown with letter indices:\n            // 0 (A), 2 (B), and 4 (C) (special characters are not counted).\n            // Therefore, when the user enters the cell for the first letter in the grid (letter index 0),\n            // the next cell will have a letter index of 2.\n            const [charIndex, nextCellEl] = this.findTheClosestCell(wordNumber, wordObj, letterIndex + 1);\n            // Assign a new letter to the clue input.\n            this.bindDataToClueInput(textEl.closest('g'), char);\n            if (!nextCellEl) {\n                return;\n            }\n            // Update code.\n            code = nextCellEl.dataset.code;\n            // Update `letterIndex`.\n            letterIndex = charIndex;\n            nextCellEl.dispatchEvent(new Event('click'));\n        }\n    }\n\n    /**\n     * Add event to word input element.\n     *\n     * @param {Element} inputEl The input element.\n     */\n    addEventForWordInput(inputEl) {\n        const {readonly} = this.options;\n        if (readonly) {\n            return;\n        }\n\n        // Handle IME input.\n        inputEl.addEventListener('beforeinput', (e) => {\n            if (e.inputType === 'insertText' && e.data) {\n                this.handleInsertTextEventForGridInput(e, e.data);\n            }\n        });\n\n        inputEl.addEventListener('keypress', (e) => {\n            e.preventDefault();\n            // On mobile devices, the Backspace key may trigger the keypress event when the user uses Input Method Editor.\n            // Therefore, we need to prevent this behavior.\n            if (e.key === this.BACKSPACE) {\n                return false;\n            }\n            this.handleInsertTextEventForGridInput(e, e.key);\n            return true;\n        });\n\n        inputEl.addEventListener('compositionend', (evt) => {\n            evt.preventDefault();\n            evt.stopPropagation();\n            const {wordNumber, words} = this.options;\n            const wordObj = words.find(word => word.number === parseInt(wordNumber));\n            let key = evt.data.toUpperCase();\n            const code = evt.target.dataset.code;\n            if (this.replaceText(key) === '') {\n                return false;\n            }\n            if (code) {\n                let chars = key.split('');\n                const gEl = this.options.crosswordEl.querySelector(`g[data-code='${code}']`);\n                if (!gEl) {\n                    return false;\n                }\n                let letterIndex = parseInt(gEl.dataset.letterindex);\n                for (let char of chars) {\n                    if (this.replaceText(char) === '') {\n                        continue;\n                    }\n                    // Retrieve the next valid cell and its corresponding character index.\n                    const [charIndex, cellEl] = this.findTheClosestCell(wordNumber, wordObj, letterIndex);\n                    // Interact with clue.\n                    if (cellEl) {\n                        letterIndex = charIndex;\n                        cellEl.querySelector('text.crossword-cell-text').innerHTML = char;\n                        this.bindDataToClueInput(cellEl, char);\n                        // Make sure not to click when a cell is already focused.\n                        if (!cellEl.querySelector('.crossword-cell-focussed')) {\n                            cellEl.dispatchEvent(new Event('click'));\n                        }\n                        // Increment to the next letter index.\n                        letterIndex++;\n                    }\n                }\n\n                const nextCellEl = this.findTheClosestCell(wordNumber, wordObj, letterIndex).pop() ?? null;\n                if (nextCellEl) {\n                    nextCellEl.dispatchEvent(new Event('click'));\n                }\n            }\n            return true;\n        });\n\n        inputEl.addEventListener('keyup', (event) => {\n            event.preventDefault();\n            const {wordNumber, cellWidth, cellHeight, words} = this.options;\n            const {key, target} = event;\n            const code = target.dataset.code;\n            const gEl = this.options.crosswordEl.querySelector(`g[data-code='${code}']`);\n            const word = words.find(o => o.number === parseInt(wordNumber));\n            const letterIndex = this.findTheClosestCell(wordNumber, word,\n                parseInt(gEl.dataset.letterindex) - 1, false)[0];\n            const previousCell = this.options.crosswordEl.querySelector(\n                `g[data-word*='(${wordNumber})'][data-letterindex='${letterIndex}']`\n            );\n            const textEl = gEl.querySelector('text.crossword-cell-text');\n            let x = parseInt(gEl.querySelector('rect').getAttributeNS(null, 'x'));\n            let y = parseInt(gEl.querySelector('rect').getAttributeNS(null, 'y'));\n            if (key === this.DELETE || key === this.BACKSPACE) {\n                if (textEl.innerHTML === '') {\n                    if (previousCell) {\n                        previousCell.dispatchEvent(new Event('click'));\n                    }\n                } else {\n                    textEl.innerHTML = '';\n                    this.bindDataToClueInput(gEl, '_');\n                }\n            }\n            if ([this.ARROW_UP, this.ARROW_DOWN, this.ARROW_LEFT, this.ARROW_RIGHT].includes(key)) {\n                if (key === this.ARROW_UP) {\n                    y -= cellHeight;\n                }\n                if (key === this.ARROW_DOWN) {\n                    y += cellHeight;\n                }\n                if (key === this.ARROW_LEFT) {\n                    x -= cellWidth;\n                }\n                if (key === this.ARROW_RIGHT) {\n                    x += cellWidth;\n                }\n                const nextCell = this.options.crosswordEl.querySelector(`g rect[x='${x}'][y='${y}']`);\n                if (nextCell) {\n                    nextCell.closest('g').dispatchEvent(new Event('click'));\n                }\n            }\n        });\n\n        inputEl.addEventListener('click', (e) => {\n            const inputEl = e.target;\n            const code = inputEl.dataset.code;\n            const gEl = this.options.crosswordEl.querySelector(`g[data-code='${code}']`);\n            this.handleWordSelect(gEl);\n        });\n\n        inputEl.addEventListener('keydown', (e) => {\n            let {key} = e;\n            key = key.toLowerCase();\n            if (e.ctrlKey) {\n                if (\n                    key === this.Z_KEY ||\n                    key === this.A_KEY\n                ) {\n                    e.preventDefault();\n                }\n            }\n\n            if (e.key === this.ENTER) {\n                e.preventDefault();\n            }\n        });\n\n        inputEl.addEventListener('paste', (e) => {\n            e.preventDefault();\n        });\n    }\n\n    /**\n     * Add event to resize the screen width.\n     */\n    addEventResizeScreen() {\n        window.addEventListener('resize', () => {\n            this.updatePositionForCellInput();\n        });\n    }\n}\n"],"names":["CrosswordGrid","CrosswordQuestion","constructor","options","buildBackgroundTable","colsNum","rowsNum","previewSetting","this","style","tableEl","document","createElement","className","backgroundColor","i","rowEl","j","squareEl","borderColor","color","classList","add","innerText","getColumnLabel","append","crosswordEl","innerHTML","outerHTML","addCell","words","labelPlaceholder","dataset","label","orientationMarks","length","answer","trim","replace","row","startrow","column","startcolumn","answerLength","realLength","allowLength","parseInt","orientation","number","isInvalidLetter","querySelector","labelEl","labelParams","_words$i","no","labelText","index","includes","spanEl","letter","toUpperCase","contentEl","isContainSpecialCharacters","text","search","conflictColor","previewCrossword","buildCrossword","width","height","CrosswordClue","setUpClue","drawCrosswordSVG","syncDataForInit","addEventResizeScreen","svg","createElementNSFrom","viewBox","rectEl","x","y","createCrosswordBody","setSizeForCrossword","setBorder","inputContainEl","createElementFrom","inputEl","type","maxlength","autocomplete","spellcheck","autocorrect","addEventForWordInput","attributes","element","createElementNS","key","setAttributeNS","setAttribute","cellWidth","cellHeight","count","word","ignoreList","getIgnoreIndexByAnswerNumber","customAttribute","startRow","startColumn","position","calculatePosition","g","existingRectElement","textEl","existingNumberElement","closest","currentWord","appendCellNumber","wordNumber","addEventForG","strokeWidth","horizontalLine","x1","y1","x2","y2","stroke","appendChild","verticalLine","textNumber","readonly","addEventListener","e","target","tagName","handleWordSelect","code","value","updatePositionForCellInput","focus","gEl","currentCell","coordinates","match","indexCell","indexOf","undefined","find","o","updateLetterIndexForCells","toggleHighlight","focusClue","setStickyClue","rect","getBoundingClientRect","parentEl","inputWrapperEl","top","cssText","left","handleInsertTextEventForGridInput","event","upperText","replaceText","letterIndex","chars","split","wordObj","char","letterindex","charIndex","nextCellEl","findTheClosestCell","bindDataToClueInput","dispatchEvent","Event","inputType","data","preventDefault","BACKSPACE","evt","stopPropagation","cellEl","pop","previousCell","getAttributeNS","DELETE","ARROW_UP","ARROW_DOWN","ARROW_LEFT","ARROW_RIGHT","nextCell","toLowerCase","ctrlKey","Z_KEY","A_KEY","ENTER","window"],"mappings":"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"}