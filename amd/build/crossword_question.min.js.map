<<<<<<< HEAD
{"version":3,"file":"crossword_question.min.js","sources":["../src/crossword_question.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * CrosswordQuestion base class handle every common function.\n *\n * @module qtype_crossword/crossword_question\n * @copyright 2022 The Open University\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nexport class CrosswordQuestion {\n\n    // Arrow Left key.\n    ARROW_LEFT = 'ArrowLeft';\n\n    // Arrow Right key.\n    ARROW_RIGHT = 'ArrowRight';\n\n    // Arrow Up key.\n    ARROW_UP = 'ArrowUp';\n\n    // Arrow Down key.\n    ARROW_DOWN = 'ArrowDown';\n\n    // End key.\n    END = 'End';\n\n    // Home key.\n    HOME = 'Home';\n\n    // Delete key.\n    DELETE = 'Delete';\n\n    // Backspace key.\n    BACKSPACE = 'Backspace';\n\n    // Z key.\n    Z_KEY = 'z';\n\n    // A key.\n    A_KEY = 'a';\n\n    // Enter key.\n    ENTER = 'Enter';\n\n    /**\n     * Constructor for crossword question.\n     *\n     * @param {Object} options The input options for the crossword.\n     */\n    constructor(options) {\n        let defaultOption = {\n            colsNum: 10,\n            rowsNum: 10,\n            words: [],\n            target: '#crossword',\n            isPreview: false,\n            previewSetting: {backgroundColor: '#ffffff', borderColor: '#000000', textColor: '#ffffff', conflictColor: '#f4cece'},\n            cellWidth: 31,\n            cellHeight: 31,\n            wordNumber: -1,\n            coordinates: ''\n        };\n        // Merge options.\n        defaultOption = {...defaultOption, ...options};\n        // Set options.\n        this.options = defaultOption;\n        // Get target element.\n        const targetEls = document.querySelectorAll(defaultOption.target);\n        for (let i = 0; i < targetEls.length; i++) {\n            if (!targetEls[i].querySelector('svg')) {\n                this.crosswordEl = targetEls[i];\n                this.options.crosswordEl = targetEls[i];\n                if (!this.options.isPreview) {\n                    this.options.words = this.retrieveWordData();\n                }\n                break;\n            }\n        }\n    }\n\n    /**\n     * Get word data.\n     *\n     * @return {Array} Word data list.\n     */\n    retrieveWordData() {\n        const clueEls = this.options.crosswordEl\n            .closest('.qtype_crossword-grid-wrapper')\n            .querySelectorAll('.contain-clue .wrap-clue');\n        if (clueEls.length === 0) {\n            return [];\n        }\n        return [...clueEls].map(el => {\n            const number = parseInt(el.dataset.questionid);\n            const startRow = parseInt(el.dataset.startrow);\n            const startColumn = parseInt(el.dataset.startcolumn);\n            const length = parseInt(el.dataset.length);\n            const orientation = parseInt(el.dataset.orientation);\n            const clue = el.dataset.clue;\n            return {number, startRow, startColumn, length, orientation, clue};\n        }).sort((clueA, clueB) => clueA.number - clueB.number);\n    }\n\n    /**\n     * Get alphabet character from the index.\n     *\n     * @param {Number} index The character index number start from 0.\n     *\n     * @return {String} Alphabet character, In case index number higher than 25,\n     *  we will add one letter before the current one like Excel: AA, AB, AC, AD, AE etc.\n     */\n    getColumnLabel(index) {\n        let text = '';\n\n        // Get the integer of division and subtraction by 1,\n        // The firstLetterIndex will start from -1\n        // and increments every index adding more 26.\n        const firstLetterIndex = Math.trunc(index / 26) - 1;\n\n        // Get remainder from division result.\n        // The lastLetterIndex value is the index of the second letter.\n        let lastLetterIndex = index % 26;\n\n        // In case firstLetterIndex < -1 we will not show the first letter.\n        if (firstLetterIndex > -1) {\n            text = this.retrieveCharacterByIndex(firstLetterIndex);\n        }\n        // Adding the last letter.\n        text += this.retrieveCharacterByIndex(lastLetterIndex);\n\n        return text;\n    }\n\n    /**\n     * Get alphabet character by index.\n     *\n     * @param {Number} index Position character number.\n     * @return {String} Alphabet character.\n     */\n    retrieveCharacterByIndex(index) {\n        return String.fromCharCode(\"A\".charCodeAt(0) + index);\n    }\n\n    /**\n     * The answer must not contain any special character.\n     *\n     * @param {String} answer The answer string need to be check.\n     * @return {Boolean} The value data.\n     */\n    isInvalidAnswer = function(answer) {\n        return /[-@!$%^&*()_+|~=`\\\\#{}[\\]:\";'<>?,./]/gi.test(answer);\n    };\n\n    /**\n     * Generate underscore letter by length.\n     *\n     * @param {Number} length Expected length.\n     *\n     * @return {String} Underscore string.\n     */\n    makeUnderscore(length) {\n        const arr = Array.from({length}, () => '_');\n        return arr.join('');\n    }\n\n    /**\n     * Update the letter index of the word based on the word selected.\n     *\n     * @param {Object} word The word object.\n     */\n    updateLetterIndexForCells(word) {\n        const {wordNumber} = this.options;\n        const letterList = this.options.crosswordEl.querySelectorAll(`g[data-word*='(${wordNumber})']`);\n        // Convert letterList to array to use sort function.\n        const letterListArray = Array.prototype.slice.call(letterList, 0);\n        let letterIndex = 0;\n        // Rearrange the letters in the correct order.\n        letterListArray.sort((a, b) => {\n            let aValue = parseInt(a.querySelector('rect').getAttributeNS(null, 'x'));\n            let bValue = parseInt(b.querySelector('rect').getAttributeNS(null, 'x'));\n            if (word.orientation) {\n                aValue = parseInt(a.querySelector('rect').getAttributeNS(null, 'y'));\n                bValue = parseInt(b.querySelector('rect').getAttributeNS(null, 'y'));\n            }\n            return aValue - bValue;\n        }).forEach(el => {\n            // Update letter index.\n            el.dataset.letterindex = letterIndex;\n            letterIndex++;\n        });\n    }\n\n    /**\n     * Toggle focus the clue.\n     */\n    focusClue() {\n        const {wordNumber} = this.options;\n        const containCrosswordEl = this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper');\n        const clueEl = containCrosswordEl.querySelector(`.wrap-clue[data-questionid='${wordNumber}']`);\n        const clueFocusEl = containCrosswordEl.querySelector(`.wrap-clue.focus`);\n        // Remove the current focus cell.\n        if (clueFocusEl) {\n            clueFocusEl.classList.remove('focus');\n        }\n        // Add focus cell.\n        if (clueEl) {\n            clueEl.classList.add('focus');\n        }\n    }\n\n    /**\n     * Set sticky clue for the mobile version.\n     */\n    setStickyClue() {\n        const stickyClue = this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper').querySelector('.sticky-clue');\n        const {wordNumber, words} = this.options;\n        const word = words.find(o => o.number === parseInt(wordNumber));\n        if (!stickyClue && word) {\n            return;\n        }\n        let strongEl = stickyClue.querySelector('strong');\n        let spanEl = stickyClue.querySelector('span');\n        if (!strongEl) {\n            strongEl = document.createElement('strong');\n            strongEl.classList.add('mr-1');\n            stickyClue.append(strongEl);\n        }\n        if (!spanEl) {\n            spanEl = document.createElement('span');\n            stickyClue.append(spanEl);\n        }\n        strongEl.innerText = `${word.number} ${this.options.orientation[word.orientation]}`;\n        spanEl.innerText = `${word.clue} (${word.length})`;\n    }\n\n    /**\n     * Focus crossword cell from the start index.\n     *\n     * @param {String} value The value string need to be replaced.\n     * @return {String} The value data.\n     */\n    replaceText(value) {\n        return value.replace(/[-@!$%^&*()_+|~=`\\\\#{}[\\]:\";'<>?,./]/gi, '');\n    }\n\n    /**\n     * Bind data to the clue.\n     *\n     * @param {Element} gEl The word letter.\n     * @param {String} key The letter data.\n     */\n    bindDataToClueInput(gEl, key) {\n        const {words, cellWidth, cellHeight} = this.options;\n        const rectEl = gEl.querySelector('rect');\n        const conflictPointX = rectEl.getAttributeNS(null, 'x');\n        const conflictPointY = rectEl.getAttributeNS(null, 'y');\n        let letterIndex, value;\n        if (gEl) {\n            let wordIds = gEl.dataset.word.match(/\\d+/g);\n            wordIds.forEach(wordId => {\n                const word = words.find(o => o.number === parseInt(wordId));\n                if (word) {\n                    const startPoint = this.calculatePosition(word, 0);\n                    if (word.orientation) {\n                        letterIndex = (parseInt(conflictPointY) - startPoint.y) / (cellHeight + 1);\n                    } else {\n                        letterIndex = (parseInt(conflictPointX) - startPoint.x) / (cellWidth + 1);\n                    }\n                    const clueInputEl = this.options.crosswordEl\n                        .closest('.qtype_crossword-grid-wrapper')\n                        .querySelector(`.wrap-clue[data-questionid='${wordId}'] input`);\n                    value = this.replaceAt(clueInputEl.value, letterIndex, key);\n                    clueInputEl.value = value.toUpperCase();\n                }\n            });\n        }\n    }\n\n    /**\n     * Calculate the position of each letter of the word.\n     *\n     * @param {Object} word The current word object.\n     * @param {Number} key The letter index of word.\n     *\n     * @return {Object} The coordinates of letter.\n     */\n    calculatePosition(word, key) {\n        const {cellWidth, cellHeight} = this.options;\n        let x = (cellWidth * word.startColumn) + (word.startColumn + 1);\n        let y = (cellHeight * word.startRow) + (word.startRow + 1);\n        if (word.orientation) {\n            y += (key * cellHeight) + key;\n        } else {\n            x += (key * cellWidth) + key;\n        }\n        return {x, y};\n    }\n\n    /**\n     * Replace letter at index.\n     *\n     * @param {String} text Text need to be replaced.\n     * @param {Number} index Letter index.\n     * @param {String} char The replace letter.\n     *\n     * @return {String} Underscore string.\n     */\n    replaceAt(text, index, char) {\n        let a = text.split('');\n        if (a[index] !== undefined) {\n            a[index] = char;\n        }\n        return a.join('');\n    }\n\n    /**\n     * Sync data to crossword cell from text.\n     *\n     * @param {Element} text The text data.\n     * @param {Boolean} [bindClue=false] Check if bind data into clue.\n     */\n    syncLettersByText(text, bindClue = true) {\n        const {wordNumber} = this.options;\n        for (let i in text) {\n            const gEl = this.options.crosswordEl.querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${i}']`);\n            if (gEl) {\n                const letter = text[i].toUpperCase();\n                const textEl = gEl.querySelector('text.crossword-cell-text');\n                if (text[i] !== '_') {\n                    textEl.innerHTML = letter;\n                } else {\n                    textEl.innerHTML = '';\n                }\n                if (bindClue) {\n                    this.bindDataToClueInput(gEl, letter);\n                }\n            }\n        }\n    }\n\n    /**\n     * Toggle the highlight cells.\n     *\n     * @param {Object} word The word object.\n     * @param {Element} gEl The g element.\n     */\n    toggleHighlight(word, gEl) {\n        const {wordNumber, orientation, title} = this.options;\n        const focus = wordNumber;\n        const focusedEl = this.options.crosswordEl.querySelector('.crossword-cell-focussed');\n        if (focusedEl) {\n            focusedEl.classList.remove('crossword-cell-focussed');\n        }\n        // Remove current highlight cells.\n        this.options.crosswordEl.querySelectorAll('.crossword-cell-highlighted')\n            .forEach(el => el.classList.remove('crossword-cell-highlighted'));\n        // Set highlight cells.\n        this.options.crosswordEl.querySelectorAll(`g[data-word*='(${focus})'] rect`)\n            .forEach(el => {\n                    let titleData = '';\n                    if (el.closest('g').dataset.code === gEl.dataset.code) {\n                        el.classList.add('crossword-cell-focussed');\n                        // Update aria label.\n                        let letterIndex = parseInt(el.closest('g').dataset.letterindex);\n                        const data = {\n                            row: word.startRow + 1,\n                            column: word.startColumn + letterIndex + 1,\n                            number: word.number,\n                            orientation: orientation[word.orientation],\n                            clue: word.clue,\n                            letter: letterIndex + 1,\n                            count: word.length\n                        };\n                        if (word.orientation) {\n                            data.row = word.startRow + letterIndex + 1;\n                            data.column = word.startColumn + 1;\n                        }\n                        titleData = this.replaceStringData(title, data);\n                        this.options.crosswordEl.querySelector('input.crossword-hidden-input')\n                            .setAttributeNS(null, 'aria-label', titleData);\n\n                    } else {\n                        el.classList.add('crossword-cell-highlighted');\n                    }\n                }\n            );\n    }\n\n    /**\n     * Replace string data.\n     *\n     * @param {String} str The string need to be replaced.\n     * @param {Object} data The data.\n     *\n     * @return {String} The replaced string.\n     */\n    replaceStringData(str, data) {\n        for (let key in data) {\n            str = str.replace(`{${key}}`, data[key]);\n        }\n        return str;\n    }\n\n    /**\n     * Sync data between clue section and crossword.\n     */\n    syncDataForInit() {\n        const {words} = this.options;\n        // Loop every input into clue section.\n        this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper').querySelectorAll('.wrap-clue input')\n            .forEach(element => {\n                // Tricky, update word number.\n                this.options.wordNumber = parseInt(element.closest('.wrap-clue').dataset.questionid);\n                const word = words.find(o => o.number === this.options.wordNumber);\n                if (!word) {\n                    return;\n                }\n                // Sorting and Updating letter index.\n                this.updateLetterIndexForCells(word);\n                // The value will be filled into the valid cell.\n                this.syncLettersByText(element.value, false);\n            });\n        // Set wordNumber by default value.\n        this.options.wordNumber = -1;\n    }\n}\n"],"names":["constructor","options","answer","test","defaultOption","colsNum","rowsNum","words","target","isPreview","previewSetting","backgroundColor","borderColor","textColor","conflictColor","cellWidth","cellHeight","wordNumber","coordinates","targetEls","document","querySelectorAll","i","length","querySelector","crosswordEl","this","retrieveWordData","clueEls","closest","map","el","number","parseInt","dataset","questionid","startRow","startrow","startColumn","startcolumn","orientation","clue","sort","clueA","clueB","getColumnLabel","index","text","firstLetterIndex","Math","trunc","lastLetterIndex","retrieveCharacterByIndex","String","fromCharCode","charCodeAt","makeUnderscore","Array","from","join","updateLetterIndexForCells","word","letterList","letterListArray","prototype","slice","call","letterIndex","a","b","aValue","getAttributeNS","bValue","forEach","letterindex","focusClue","containCrosswordEl","clueEl","clueFocusEl","classList","remove","add","setStickyClue","stickyClue","find","o","strongEl","spanEl","createElement","append","innerText","replaceText","value","replace","bindDataToClueInput","gEl","key","rectEl","conflictPointX","conflictPointY","match","wordId","startPoint","calculatePosition","y","x","clueInputEl","replaceAt","toUpperCase","char","split","undefined","syncLettersByText","bindClue","letter","textEl","innerHTML","toggleHighlight","title","focus","focusedEl","titleData","code","data","row","column","count","replaceStringData","setAttributeNS","str","syncDataForInit","element"],"mappings":";;;;;;;gIA+DIA,YAAYC,2CArCC,gDAGC,8CAGH,6CAGE,wCAGP,mCAGC,sCAGE,2CAGG,0CAGJ,kCAGA,kCAGA,iDA2GU,SAASC,cAChB,yCAAyCC,KAAKD,eApGjDE,cAAgB,CAChBC,QAAS,GACTC,QAAS,GACTC,MAAO,GACPC,OAAQ,aACRC,WAAW,EACXC,eAAgB,CAACC,gBAAiB,UAAWC,YAAa,UAAWC,UAAW,UAAWC,cAAe,WAC1GC,UAAW,GACXC,WAAY,GACZC,YAAa,EACbC,YAAa,IAGjBd,cAAgB,IAAIA,iBAAkBH,cAEjCA,QAAUG,oBAETe,UAAYC,SAASC,iBAAiBjB,cAAcI,YACrD,IAAIc,EAAI,EAAGA,EAAIH,UAAUI,OAAQD,QAC7BH,UAAUG,GAAGE,cAAc,OAAQ,MAC/BC,YAAcN,UAAUG,QACxBrB,QAAQwB,YAAcN,UAAUG,GAChCI,KAAKzB,QAAQQ,iBACTR,QAAQM,MAAQmB,KAAKC,2BAY1CA,yBACUC,QAAUF,KAAKzB,QAAQwB,YACxBI,QAAQ,iCACRR,iBAAiB,mCACC,IAAnBO,QAAQL,OACD,GAEJ,IAAIK,SAASE,KAAIC,KAOb,CAACC,OANOC,SAASF,GAAGG,QAAQC,YAMnBC,SALCH,SAASF,GAAGG,QAAQG,UAKXC,YAJNL,SAASF,GAAGG,QAAQK,aAIDhB,OAHxBU,SAASF,GAAGG,QAAQX,QAGYiB,YAF3BP,SAASF,GAAGG,QAAQM,aAEoBC,KAD/CV,GAAGG,QAAQO,SAEzBC,MAAK,CAACC,MAAOC,QAAUD,MAAMX,OAASY,MAAMZ,SAWnDa,eAAeC,WACPC,KAAO,SAKLC,iBAAmBC,KAAKC,MAAMJ,MAAQ,IAAM,MAI9CK,gBAAkBL,MAAQ,UAG1BE,kBAAoB,IACpBD,KAAOrB,KAAK0B,yBAAyBJ,mBAGzCD,MAAQrB,KAAK0B,yBAAyBD,iBAE/BJ,KASXK,yBAAyBN,cACdO,OAAOC,aAAa,IAAIC,WAAW,GAAKT,OAoBnDU,eAAejC,eACCkC,MAAMC,KAAK,CAACnC,OAAAA,SAAS,IAAM,MAC5BoC,KAAK,IAQpBC,0BAA0BC,YAChB5C,WAACA,YAAcS,KAAKzB,QACpB6D,WAAapC,KAAKzB,QAAQwB,YAAYJ,0CAAmCJ,mBAEzE8C,gBAAkBN,MAAMO,UAAUC,MAAMC,KAAKJ,WAAY,OAC3DK,YAAc,EAElBJ,gBAAgBrB,MAAK,CAAC0B,EAAGC,SACjBC,OAASrC,SAASmC,EAAE5C,cAAc,QAAQ+C,eAAe,KAAM,MAC/DC,OAASvC,SAASoC,EAAE7C,cAAc,QAAQ+C,eAAe,KAAM,aAC/DV,KAAKrB,cACL8B,OAASrC,SAASmC,EAAE5C,cAAc,QAAQ+C,eAAe,KAAM,MAC/DC,OAASvC,SAASoC,EAAE7C,cAAc,QAAQ+C,eAAe,KAAM,OAE5DD,OAASE,UACjBC,SAAQ1C,KAEPA,GAAGG,QAAQwC,YAAcP,YACzBA,iBAORQ,kBACU1D,WAACA,YAAcS,KAAKzB,QACpB2E,mBAAqBlD,KAAKzB,QAAQwB,YAAYI,QAAQ,iCACtDgD,OAASD,mBAAmBpD,oDAA6CP,kBACzE6D,YAAcF,mBAAmBpD,kCAEnCsD,aACAA,YAAYC,UAAUC,OAAO,SAG7BH,QACAA,OAAOE,UAAUE,IAAI,SAO7BC,sBACUC,WAAazD,KAAKzB,QAAQwB,YAAYI,QAAQ,iCAAiCL,cAAc,iBAC7FP,WAACA,WAADV,MAAaA,OAASmB,KAAKzB,QAC3B4D,KAAOtD,MAAM6E,MAAKC,GAAKA,EAAErD,SAAWC,SAAShB,kBAC9CkE,YAActB,gBAGfyB,SAAWH,WAAW3D,cAAc,UACpC+D,OAASJ,WAAW3D,cAAc,QACjC8D,WACDA,SAAWlE,SAASoE,cAAc,UAClCF,SAASP,UAAUE,IAAI,QACvBE,WAAWM,OAAOH,WAEjBC,SACDA,OAASnE,SAASoE,cAAc,QAChCL,WAAWM,OAAOF,SAEtBD,SAASI,oBAAe7B,KAAK7B,mBAAUN,KAAKzB,QAAQuC,YAAYqB,KAAKrB,cACrE+C,OAAOG,oBAAe7B,KAAKpB,kBAASoB,KAAKtC,YAS7CoE,YAAYC,cACDA,MAAMC,QAAQ,yCAA0C,IASnEC,oBAAoBC,IAAKC,WACfzF,MAACA,MAADQ,UAAQA,UAARC,WAAmBA,YAAcU,KAAKzB,QACtCgG,OAASF,IAAIvE,cAAc,QAC3B0E,eAAiBD,OAAO1B,eAAe,KAAM,KAC7C4B,eAAiBF,OAAO1B,eAAe,KAAM,SAC/CJ,YAAayB,SACbG,IAAK,CACSA,IAAI7D,QAAQ2B,KAAKuC,MAAM,QAC7B3B,SAAQ4B,eACNxC,KAAOtD,MAAM6E,MAAKC,GAAKA,EAAErD,SAAWC,SAASoE,aAC/CxC,KAAM,OACAyC,WAAa5E,KAAK6E,kBAAkB1C,KAAM,GAE5CM,YADAN,KAAKrB,aACUP,SAASkE,gBAAkBG,WAAWE,IAAMxF,WAAa,IAEzDiB,SAASiE,gBAAkBI,WAAWG,IAAM1F,UAAY,SAErE2F,YAAchF,KAAKzB,QAAQwB,YAC5BI,QAAQ,iCACRL,oDAA6C6E,oBAClDT,MAAQlE,KAAKiF,UAAUD,YAAYd,MAAOzB,YAAa6B,KACvDU,YAAYd,MAAQA,MAAMgB,mBAc1CL,kBAAkB1C,KAAMmC,WACdjF,UAACA,UAADC,WAAYA,YAAcU,KAAKzB,YACjCwG,EAAK1F,UAAY8C,KAAKvB,aAAgBuB,KAAKvB,YAAc,GACzDkE,EAAKxF,WAAa6C,KAAKzB,UAAayB,KAAKzB,SAAW,UACpDyB,KAAKrB,YACLgE,GAAMR,IAAMhF,WAAcgF,IAE1BS,GAAMT,IAAMjF,UAAaiF,IAEtB,CAACS,EAAAA,EAAGD,EAAAA,GAYfG,UAAU5D,KAAMD,MAAO+D,UACfzC,EAAIrB,KAAK+D,MAAM,gBACFC,IAAb3C,EAAEtB,SACFsB,EAAEtB,OAAS+D,MAERzC,EAAET,KAAK,IASlBqD,kBAAkBjE,UAAMkE,0EACdhG,WAACA,YAAcS,KAAKzB,YACrB,IAAIqB,KAAKyB,KAAM,OACVgD,IAAMrE,KAAKzB,QAAQwB,YAAYD,uCAAgCP,4CAAmCK,YACpGyE,IAAK,OACCmB,OAASnE,KAAKzB,GAAGsF,cACjBO,OAASpB,IAAIvE,cAAc,4BACjB,MAAZuB,KAAKzB,GACL6F,OAAOC,UAAYF,OAEnBC,OAAOC,UAAY,GAEnBH,eACKnB,oBAAoBC,IAAKmB,UAY9CG,gBAAgBxD,KAAMkC,WACZ9E,WAACA,WAADuB,YAAaA,YAAb8E,MAA0BA,OAAS5F,KAAKzB,QACxCsH,MAAQtG,WACRuG,UAAY9F,KAAKzB,QAAQwB,YAAYD,cAAc,4BACrDgG,WACAA,UAAUzC,UAAUC,OAAO,gCAG1B/E,QAAQwB,YAAYJ,iBAAiB,+BACrCoD,SAAQ1C,IAAMA,GAAGgD,UAAUC,OAAO,qCAElC/E,QAAQwB,YAAYJ,0CAAmCkG,mBACvD9C,SAAQ1C,SACG0F,UAAY,MACZ1F,GAAGF,QAAQ,KAAKK,QAAQwF,OAAS3B,IAAI7D,QAAQwF,KAAM,CACnD3F,GAAGgD,UAAUE,IAAI,+BAEbd,YAAclC,SAASF,GAAGF,QAAQ,KAAKK,QAAQwC,mBAC7CiD,KAAO,CACTC,IAAK/D,KAAKzB,SAAW,EACrByF,OAAQhE,KAAKvB,YAAc6B,YAAc,EACzCnC,OAAQ6B,KAAK7B,OACbQ,YAAaA,YAAYqB,KAAKrB,aAC9BC,KAAMoB,KAAKpB,KACXyE,OAAQ/C,YAAc,EACtB2D,MAAOjE,KAAKtC,QAEZsC,KAAKrB,cACLmF,KAAKC,IAAM/D,KAAKzB,SAAW+B,YAAc,EACzCwD,KAAKE,OAAShE,KAAKvB,YAAc,GAErCmF,UAAY/F,KAAKqG,kBAAkBT,MAAOK,WACrC1H,QAAQwB,YAAYD,cAAc,gCAClCwG,eAAe,KAAM,aAAcP,gBAGxC1F,GAAGgD,UAAUE,IAAI,iCAcrC8C,kBAAkBE,IAAKN,UACd,IAAI3B,OAAO2B,KACZM,IAAMA,IAAIpC,mBAAYG,SAAQ2B,KAAK3B,aAEhCiC,IAMXC,wBACU3H,MAACA,OAASmB,KAAKzB,aAEhBA,QAAQwB,YAAYI,QAAQ,iCAAiCR,iBAAiB,oBAC9EoD,SAAQ0D,eAEAlI,QAAQgB,WAAagB,SAASkG,QAAQtG,QAAQ,cAAcK,QAAQC,kBACnE0B,KAAOtD,MAAM6E,MAAKC,GAAKA,EAAErD,SAAWN,KAAKzB,QAAQgB,aAClD4C,YAIAD,0BAA0BC,WAE1BmD,kBAAkBmB,QAAQvC,OAAO,YAGzC3F,QAAQgB,YAAc"}
=======
<<<<<<< HEAD
{"version":3,"file":"crossword_question.min.js","sources":["../src/crossword_question.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * CrosswordQuestion base class handle every common function.\n *\n * @module qtype_crossword/crossword_question\n * @copyright 2022 The Open University\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nexport class CrosswordQuestion {\n\n    // Arrow Left key.\n    ARROW_LEFT = 'ArrowLeft';\n\n    // Arrow Right key.\n    ARROW_RIGHT = 'ArrowRight';\n\n    // Arrow Up key.\n    ARROW_UP = 'ArrowUp';\n\n    // Arrow Down key.\n    ARROW_DOWN = 'ArrowDown';\n\n    // End key.\n    END = 'End';\n\n    // Home key.\n    HOME = 'Home';\n\n    // Delete key.\n    DELETE = 'Delete';\n\n    // Backspace key.\n    BACKSPACE = 'Backspace';\n\n    // Z key.\n    Z_KEY = 'z';\n\n    // A key.\n    A_KEY = 'a';\n\n    // Enter key.\n    ENTER = 'Enter';\n\n    /**\n     * Constructor for crossword question.\n     *\n     * @param {Object} options The input options for the crossword.\n     */\n    constructor(options) {\n        let defaultOption = {\n            colsNum: 10,\n            rowsNum: 10,\n            words: [],\n            target: '#crossword',\n            isPreview: false,\n            previewSetting: {backgroundColor: '#ffffff', borderColor: '#000000', textColor: '#ffffff', conflictColor: '#f4cece'},\n            cellWidth: 31,\n            cellHeight: 31,\n            wordNumber: -1,\n            coordinates: ''\n        };\n        // Merge options.\n        defaultOption = {...defaultOption, ...options};\n        // Set options.\n        this.options = defaultOption;\n        // Get target element.\n        const targetEls = document.querySelectorAll(defaultOption.target);\n        for (let i = 0; i < targetEls.length; i++) {\n            if (!targetEls[i].querySelector('svg')) {\n                this.crosswordEl = targetEls[i];\n                this.options.crosswordEl = targetEls[i];\n                if (!this.options.isPreview) {\n                    this.options.words = this.retrieveWordData();\n                }\n                break;\n            }\n        }\n    }\n\n    /**\n     * Get word data.\n     *\n     * @return {Array} Word data list.\n     */\n    retrieveWordData() {\n        const clueEls = this.options.crosswordEl\n            .closest('.qtype_crossword-grid-wrapper')\n            .querySelectorAll('.contain-clue .wrap-clue');\n        if (clueEls.length === 0) {\n            return [];\n        }\n        return [...clueEls].map(el => {\n            const number = parseInt(el.dataset.questionid);\n            const startRow = parseInt(el.dataset.startrow);\n            const startColumn = parseInt(el.dataset.startcolumn);\n            const length = parseInt(el.dataset.length);\n            const orientation = parseInt(el.dataset.orientation);\n            const clue = el.dataset.clue;\n            return {number, startRow, startColumn, length, orientation, clue};\n        }).sort((clueA, clueB) => clueA.number - clueB.number);\n    }\n\n    /**\n     * Get alphabet character from position number.\n     *\n     * @param {Number} i Position character number.\n     * @return {String} Alphabet character.\n     */\n    getColumnLabel(i) {\n        return String.fromCharCode(\"A\".charCodeAt(0) + i - 1);\n    }\n\n    /**\n     * The answer must not contain any special character.\n     *\n     * @param {String} answer The answer string need to be check.\n     * @return {Boolean} The value data.\n     */\n    isInvalidAnswer = function(answer) {\n        return /[-@!$%^&*()_+|~=`\\\\#{}[\\]:\";'<>?,./]/gi.test(answer);\n    };\n\n    /**\n     * Generate underscore letter by length.\n     *\n     * @param {Number} length Expected length.\n     *\n     * @return {String} Underscore string.\n     */\n    makeUnderscore(length) {\n        const arr = Array.from({length}, () => '_');\n        return arr.join('');\n    }\n\n    /**\n     * Update the letter index of the word based on the word selected.\n     *\n     * @param {Object} word The word object.\n     */\n    updateLetterIndexForCells(word) {\n        const {wordNumber} = this.options;\n        const letterList = this.options.crosswordEl.querySelectorAll(`g[data-word*='(${wordNumber})']`);\n        // Convert letterList to array to use sort function.\n        const letterListArray = Array.prototype.slice.call(letterList, 0);\n        let letterIndex = 0;\n        // Rearrange the letters in the correct order.\n        letterListArray.sort((a, b) => {\n            let aValue = parseInt(a.querySelector('rect').getAttributeNS(null, 'x'));\n            let bValue = parseInt(b.querySelector('rect').getAttributeNS(null, 'x'));\n            if (word.orientation) {\n                aValue = parseInt(a.querySelector('rect').getAttributeNS(null, 'y'));\n                bValue = parseInt(b.querySelector('rect').getAttributeNS(null, 'y'));\n            }\n            return aValue - bValue;\n        }).forEach(el => {\n            // Update letter index.\n            el.dataset.letterindex = letterIndex;\n            letterIndex++;\n        });\n    }\n\n    /**\n     * Toggle focus the clue.\n     */\n    focusClue() {\n        const {wordNumber} = this.options;\n        const containCrosswordEl = this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper');\n        const clueEl = containCrosswordEl.querySelector(`.wrap-clue[data-questionid='${wordNumber}']`);\n        const clueFocusEl = containCrosswordEl.querySelector(`.wrap-clue.focus`);\n        // Remove the current focus cell.\n        if (clueFocusEl) {\n            clueFocusEl.classList.remove('focus');\n        }\n        // Add focus cell.\n        if (clueEl) {\n            clueEl.classList.add('focus');\n        }\n    }\n\n    /**\n     * Set sticky clue for the mobile version.\n     */\n    setStickyClue() {\n        const stickyClue = this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper').querySelector('.sticky-clue');\n        const {wordNumber, words} = this.options;\n        const word = words.find(o => o.number === parseInt(wordNumber));\n        if (!stickyClue && word) {\n            return;\n        }\n        let strongEl = stickyClue.querySelector('strong');\n        let spanEl = stickyClue.querySelector('span');\n        if (!strongEl) {\n            strongEl = document.createElement('strong');\n            strongEl.classList.add('mr-1');\n            stickyClue.append(strongEl);\n        }\n        if (!spanEl) {\n            spanEl = document.createElement('span');\n            stickyClue.append(spanEl);\n        }\n        strongEl.innerText = `${word.number} ${this.options.orientation[word.orientation]}`;\n        spanEl.innerText = `${word.clue} (${word.length})`;\n    }\n\n    /**\n     * Focus crossword cell from the start index.\n     *\n     * @param {String} value The value string need to be replaced.\n     * @return {String} The value data.\n     */\n    replaceText(value) {\n        return value.replace(/[-@!$%^&*()_+|~=`\\\\#{}[\\]:\";'<>?,./]/gi, '');\n    }\n\n    /**\n     * Bind data to the clue.\n     *\n     * @param {Element} gEl The word letter.\n     * @param {String} key The letter data.\n     */\n    bindDataToClueInput(gEl, key) {\n        const {words, cellWidth, cellHeight} = this.options;\n        const rectEl = gEl.querySelector('rect');\n        const conflictPointX = rectEl.getAttributeNS(null, 'x');\n        const conflictPointY = rectEl.getAttributeNS(null, 'y');\n        let letterIndex, value;\n        if (gEl) {\n            let wordIds = gEl.dataset.word.match(/\\d+/g);\n            wordIds.forEach(wordId => {\n                const word = words.find(o => o.number === parseInt(wordId));\n                if (word) {\n                    const startPoint = this.calculatePosition(word, 0);\n                    if (word.orientation) {\n                        letterIndex = (parseInt(conflictPointY) - startPoint.y) / (cellHeight + 1);\n                    } else {\n                        letterIndex = (parseInt(conflictPointX) - startPoint.x) / (cellWidth + 1);\n                    }\n                    const clueInputEl = this.options.crosswordEl\n                        .closest('.qtype_crossword-grid-wrapper')\n                        .querySelector(`.wrap-clue[data-questionid='${wordId}'] input`);\n                    value = this.replaceAt(clueInputEl.value, letterIndex, key);\n                    clueInputEl.value = value.toUpperCase();\n                }\n            });\n        }\n    }\n\n    /**\n     * Calculate the position of each letter of the word.\n     *\n     * @param {Object} word The current word object.\n     * @param {Number} key The letter index of word.\n     *\n     * @return {Object} The coordinates of letter.\n     */\n    calculatePosition(word, key) {\n        const {cellWidth, cellHeight} = this.options;\n        let x = (cellWidth * word.startColumn) + (word.startColumn + 1);\n        let y = (cellHeight * word.startRow) + (word.startRow + 1);\n        if (word.orientation) {\n            y += (key * cellHeight) + key;\n        } else {\n            x += (key * cellWidth) + key;\n        }\n        return {x, y};\n    }\n\n    /**\n     * Replace letter at index.\n     *\n     * @param {String} text Text need to be replaced.\n     * @param {Number} index Letter index.\n     * @param {String} char The replace letter.\n     *\n     * @return {String} Underscore string.\n     */\n    replaceAt(text, index, char) {\n        let a = text.split('');\n        if (a[index] !== undefined) {\n            a[index] = char;\n        }\n        return a.join('');\n    }\n\n    /**\n     * Sync data to crossword cell from text.\n     *\n     * @param {Element} text The text data.\n     * @param {Boolean} [bindClue=false] Check if bind data into clue.\n     */\n    syncLettersByText(text, bindClue = true) {\n        const {wordNumber} = this.options;\n        for (let i in text) {\n            const gEl = this.options.crosswordEl.querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${i}']`);\n            if (gEl) {\n                const letter = text[i].toUpperCase();\n                const textEl = gEl.querySelector('text.crossword-cell-text');\n                if (text[i] !== '_') {\n                    textEl.innerHTML = letter;\n                } else {\n                    textEl.innerHTML = '';\n                }\n                if (bindClue) {\n                    this.bindDataToClueInput(gEl, letter);\n                }\n            }\n        }\n    }\n\n    /**\n     * Toggle the highlight cells.\n     *\n     * @param {Object} word The word object.\n     * @param {Element} gEl The g element.\n     */\n    toggleHighlight(word, gEl) {\n        const {wordNumber, orientation, title} = this.options;\n        const focus = wordNumber;\n        const focusedEl = this.options.crosswordEl.querySelector('.crossword-cell-focussed');\n        if (focusedEl) {\n            focusedEl.classList.remove('crossword-cell-focussed');\n        }\n        // Remove current highlight cells.\n        this.options.crosswordEl.querySelectorAll('.crossword-cell-highlighted')\n            .forEach(el => el.classList.remove('crossword-cell-highlighted'));\n        // Set highlight cells.\n        this.options.crosswordEl.querySelectorAll(`g[data-word*='(${focus})'] rect`)\n            .forEach(el => {\n                    let titleData = '';\n                    if (el.closest('g').dataset.code === gEl.dataset.code) {\n                        el.classList.add('crossword-cell-focussed');\n                        // Update aria label.\n                        let letterIndex = parseInt(el.closest('g').dataset.letterindex);\n                        const data = {\n                            row: word.startRow + 1,\n                            column: word.startColumn + letterIndex + 1,\n                            number: word.number,\n                            orientation: orientation[word.orientation],\n                            clue: word.clue,\n                            letter: letterIndex + 1,\n                            count: word.length\n                        };\n                        if (word.orientation) {\n                            data.row = word.startRow + letterIndex + 1;\n                            data.column = word.startColumn + 1;\n                        }\n                        titleData = this.replaceStringData(title, data);\n                        this.options.crosswordEl.querySelector('input.crossword-hidden-input')\n                            .setAttributeNS(null, 'aria-label', titleData);\n\n                    } else {\n                        el.classList.add('crossword-cell-highlighted');\n                    }\n                }\n            );\n    }\n\n    /**\n     * Replace string data.\n     *\n     * @param {String} str The string need to be replaced.\n     * @param {Object} data The data.\n     *\n     * @return {String} The replaced string.\n     */\n    replaceStringData(str, data) {\n        for (let key in data) {\n            str = str.replace(`{${key}}`, data[key]);\n        }\n        return str;\n    }\n\n    /**\n     * Sync data between clue section and crossword.\n     */\n    syncDataForInit() {\n        const {words} = this.options;\n        // Loop every input into clue section.\n        this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper').querySelectorAll('.wrap-clue input')\n            .forEach(element => {\n                // Tricky, update word number.\n                this.options.wordNumber = parseInt(element.closest('.wrap-clue').dataset.questionid);\n                const word = words.find(o => o.number === this.options.wordNumber);\n                if (!word) {\n                    return;\n                }\n                // Sorting and Updating letter index.\n                this.updateLetterIndexForCells(word);\n                // The value will be filled into the valid cell.\n                this.syncLettersByText(element.value, false);\n            });\n        // Set wordNumber by default value.\n        this.options.wordNumber = -1;\n    }\n}\n"],"names":["constructor","options","answer","test","defaultOption","colsNum","rowsNum","words","target","isPreview","previewSetting","backgroundColor","borderColor","textColor","conflictColor","cellWidth","cellHeight","wordNumber","coordinates","targetEls","document","querySelectorAll","i","length","querySelector","crosswordEl","this","retrieveWordData","clueEls","closest","map","el","number","parseInt","dataset","questionid","startRow","startrow","startColumn","startcolumn","orientation","clue","sort","clueA","clueB","getColumnLabel","String","fromCharCode","charCodeAt","makeUnderscore","Array","from","join","updateLetterIndexForCells","word","letterList","letterListArray","prototype","slice","call","letterIndex","a","b","aValue","getAttributeNS","bValue","forEach","letterindex","focusClue","containCrosswordEl","clueEl","clueFocusEl","classList","remove","add","setStickyClue","stickyClue","find","o","strongEl","spanEl","createElement","append","innerText","replaceText","value","replace","bindDataToClueInput","gEl","key","rectEl","conflictPointX","conflictPointY","match","wordId","startPoint","calculatePosition","y","x","clueInputEl","replaceAt","toUpperCase","text","index","char","split","undefined","syncLettersByText","bindClue","letter","textEl","innerHTML","toggleHighlight","title","focus","focusedEl","titleData","code","data","row","column","count","replaceStringData","setAttributeNS","str","syncDataForInit","element"],"mappings":"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"}
=======
{"version":3,"file":"crossword_question.min.js","sources":["../src/crossword_question.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * CrosswordQuestion base class handle every common function.\n *\n * @module qtype_crossword/crossword_question\n * @copyright 2022 The Open University\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nexport class CrosswordQuestion {\n\n    // Arrow Left key.\n    ARROW_LEFT = 'ArrowLeft';\n\n    // Arrow Right key.\n    ARROW_RIGHT = 'ArrowRight';\n\n    // Arrow Up key.\n    ARROW_UP = 'ArrowUp';\n\n    // Arrow Down key.\n    ARROW_DOWN = 'ArrowDown';\n\n    // End key.\n    END = 'End';\n\n    // Home key.\n    HOME = 'Home';\n\n    // Delete key.\n    DELETE = 'Delete';\n\n    // Backspace key.\n    BACKSPACE = 'Backspace';\n\n    // Z key.\n    Z_KEY = 'z';\n\n    // A key.\n    A_KEY = 'a';\n\n    // Enter key.\n    ENTER = 'Enter';\n\n    /**\n     * Constructor for crossword question.\n     *\n     * @param {Object} options The input options for the crossword.\n     */\n    constructor(options) {\n        let defaultOption = {\n            colsNum: 10,\n            rowsNum: 10,\n            words: [],\n            target: '#crossword',\n            isPreview: false,\n            previewSetting: {backgroundColor: '#ffffff', borderColor: '#000000', textColor: '#ffffff', conflictColor: '#f4cece'},\n            cellWidth: 31,\n            cellHeight: 31,\n            wordNumber: -1,\n            coordinates: ''\n        };\n        // Merge options.\n        defaultOption = {...defaultOption, ...options};\n        // Set options.\n        this.options = defaultOption;\n        // Get target element.\n        const targetEls = document.querySelectorAll(defaultOption.target);\n        for (let i = 0; i < targetEls.length; i++) {\n            if (!targetEls[i].querySelector('svg')) {\n                this.crosswordEl = targetEls[i];\n                this.options.crosswordEl = targetEls[i];\n                break;\n            }\n        }\n    }\n\n    /**\n     * Get alphabet character from position number.\n     *\n     * @param {Number} i Position character number.\n     * @return {String} Alphabet character.\n     */\n    getColumnLabel(i) {\n        return String.fromCharCode(\"A\".charCodeAt(0) + i - 1);\n    }\n\n    /**\n     * The answer must not contain any special character.\n     *\n     * @param {String} answer The answer string need to be check.\n     * @return {Boolean} The value data.\n     */\n    isInvalidAnswer = function(answer) {\n        return /[-@!$%^&*()_+|~=`\\\\#{}[\\]:\";'<>?,./]/gi.test(answer);\n    };\n\n    /**\n     * Generate underscore letter by length.\n     *\n     * @param {Number} length Expected length.\n     *\n     * @return {String} Underscore string.\n     */\n    makeUnderscore(length) {\n        const arr = Array.from({length}, () => '_');\n        return arr.join('');\n    }\n\n    /**\n     * Update the letter index of the word based on the word selected.\n     *\n     * @param {Object} word The word object.\n     */\n    updateLetterIndexForCells(word) {\n        const {wordNumber} = this.options;\n        const letterList = this.options.crosswordEl.querySelectorAll(`g[word*='(${wordNumber})']`);\n        // Convert letterList to array to use sort function.\n        const letterListArray = Array.prototype.slice.call(letterList, 0);\n        let letterIndex = 0;\n        // Rearrange the letters in the correct order.\n        letterListArray.sort((a, b) => {\n            let aValue = parseInt(a.querySelector('rect').getAttributeNS(null, 'x'));\n            let bValue = parseInt(b.querySelector('rect').getAttributeNS(null, 'x'));\n            if (word.orientation) {\n                aValue = parseInt(a.querySelector('rect').getAttributeNS(null, 'y'));\n                bValue = parseInt(b.querySelector('rect').getAttributeNS(null, 'y'));\n            }\n            return aValue - bValue;\n        }).forEach(el => {\n            // Update letter index.\n            el.setAttributeNS(null, 'letterIndex', letterIndex);\n            letterIndex++;\n        });\n    }\n\n    /**\n     * Toggle focus the clue.\n     */\n    focusClue() {\n        const {wordNumber} = this.options;\n        const containCrosswordEl = this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper');\n        const clueEl = containCrosswordEl.querySelector(`.wrap-clue[data-questionid='${wordNumber}']`);\n        const clueFocusEl = containCrosswordEl.querySelector(`.wrap-clue.focus`);\n        // Remove the current focus cell.\n        if (clueFocusEl) {\n            clueFocusEl.classList.remove('focus');\n        }\n        // Add focus cell.\n        if (clueEl) {\n            clueEl.classList.add('focus');\n        }\n    }\n\n    /**\n     * Set sticky clue for the mobile version.\n     */\n    setStickyClue() {\n        const stickyClue = this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper').querySelector('.sticky-clue');\n        const {wordNumber, words} = this.options;\n        const word = words.find(o => o.number === parseInt(wordNumber));\n        if (!stickyClue && word) {\n            return;\n        }\n        let strongEl = stickyClue.querySelector('strong');\n        let spanEl = stickyClue.querySelector('span');\n        if (!strongEl) {\n            strongEl = document.createElement('strong');\n            strongEl.classList.add('mr-1');\n            stickyClue.append(strongEl);\n        }\n        if (!spanEl) {\n            spanEl = document.createElement('span');\n            stickyClue.append(spanEl);\n        }\n        strongEl.innerText = `${word.number} ${this.options.orientation[word.orientation]}`;\n        spanEl.innerText = `${word.clue} (${word.length})`;\n    }\n\n    /**\n     * Focus crossword cell from the start index.\n     *\n     * @param {String} value The value string need to be replaced.\n     * @return {String} The value data.\n     */\n    replaceText(value) {\n        return value.replace(/[-@!$%^&*()_+|~=`\\\\#{}[\\]:\";'<>?,./]/gi, '');\n    }\n\n    /**\n     * Bind data to the clue.\n     *\n     * @param {Element} gEl The word letter.\n     * @param {String} key The letter data.\n     */\n    bindDataToClueInput(gEl, key) {\n        const {words, cellWidth, cellHeight} = this.options;\n        const rectEl = gEl.querySelector('rect');\n        const conflictPointX = rectEl.getAttributeNS(null, 'x');\n        const conflictPointY = rectEl.getAttributeNS(null, 'y');\n        let letterIndex, value;\n        if (gEl) {\n            let wordIds = gEl.getAttributeNS(null, 'word').match(/\\d+/g);\n            wordIds.forEach(wordId => {\n                const word = words.find(o => o.number === parseInt(wordId));\n                if (word) {\n                    const startPoint = this.calculatePosition(word, 0);\n                    if (word.orientation) {\n                        letterIndex = (parseInt(conflictPointY) - startPoint.y) / (cellHeight + 1);\n                    } else {\n                        letterIndex = (parseInt(conflictPointX) - startPoint.x) / (cellWidth + 1);\n                    }\n                    const clueInputEl = this.options.crosswordEl\n                        .closest('.qtype_crossword-grid-wrapper')\n                        .querySelector(`.wrap-clue[data-questionid='${wordId}'] input`);\n                    value = this.replaceAt(clueInputEl.value, letterIndex, key);\n                    clueInputEl.value = value.toUpperCase() + this.makeUnderscore(word.length - value.length);\n                }\n            });\n        }\n    }\n\n    /**\n     * Calculate the position of each letter of the word.\n     *\n     * @param {Object} word The current word object.\n     * @param {Number} key The letter index of word.\n     *\n     * @return {Object} The coordinates of letter.\n     */\n    calculatePosition(word, key) {\n        const {cellWidth, cellHeight} = this.options;\n        let x = (cellWidth * word.startColumn) + (word.startColumn + 1);\n        let y = (cellHeight * word.startRow) + (word.startRow + 1);\n        if (word.orientation) {\n            y += (key * cellHeight) + key;\n        } else {\n            x += (key * cellWidth) + key;\n        }\n        return {x, y};\n    }\n\n    /**\n     * Replace letter at index.\n     *\n     * @param {String} text Text need to be replaced.\n     * @param {Number} index Letter index.\n     * @param {String} char The replace letter.\n     *\n     * @return {String} Underscore string.\n     */\n    replaceAt(text, index, char) {\n        let a = text.split('');\n        if (a[index] !== undefined) {\n            a[index] = char;\n        }\n        return a.join('');\n    }\n\n    /**\n     * Sync data to crossword cell from text.\n     *\n     * @param {Element} text The text data.\n     * @param {Boolean} [bindClue=false] Check if bind data into clue.\n     */\n    syncLettersByText(text, bindClue = true) {\n        const {wordNumber} = this.options;\n        for (let i in text) {\n            const gEl = this.options.crosswordEl.querySelector(`g[word*='(${wordNumber})'][letterIndex='${i}']`);\n            if (gEl) {\n                const letter = text[i].toUpperCase();\n                const textEl = gEl.querySelector('text.crossword-cell-text');\n                if (text[i] !== '_') {\n                    textEl.innerHTML = letter;\n                } else {\n                    textEl.innerHTML = '';\n                }\n                if (bindClue) {\n                    this.bindDataToClueInput(gEl, letter);\n                }\n            }\n        }\n    }\n\n    /**\n     * Toggle the highlight cells.\n     *\n     * @param {Object} word The word object.\n     * @param {Element} gEl The g element.\n     */\n    toggleHighlight(word, gEl) {\n        const {wordNumber, orientation, title} = this.options;\n        const focus = wordNumber;\n        const focusedEl = this.options.crosswordEl.querySelector('.crossword-cell-focussed');\n        if (focusedEl) {\n            focusedEl.classList.remove('crossword-cell-focussed');\n        }\n        // Remove current highlight cells.\n        this.options.crosswordEl.querySelectorAll('.crossword-cell-highlighted')\n            .forEach(el => el.classList.remove('crossword-cell-highlighted'));\n        // Set highlight cells.\n        this.options.crosswordEl.querySelectorAll(`g[word*='(${focus})'] rect`)\n            .forEach(el => {\n                    let titleData = '';\n                    if (el.closest('g').getAttributeNS(null, 'code') === gEl.getAttributeNS(null, 'code')) {\n                        el.classList.add('crossword-cell-focussed');\n                        // Update aria label.\n                        let letterIndex = parseInt(el.closest('g').getAttributeNS(null, 'letterIndex'));\n                        const data = {\n                            row: word.startRow + 1,\n                            column: word.startColumn + letterIndex + 1,\n                            number: word.number,\n                            orientation: orientation[word.orientation],\n                            clue: word.clue,\n                            letter: letterIndex + 1,\n                            count: word.length\n                        };\n                        if (word.orientation) {\n                            data.row = word.startRow + letterIndex + 1;\n                            data.column = word.startColumn + 1;\n                        }\n                        titleData = this.replaceStringData(title, data);\n                        this.options.crosswordEl.querySelector('input.crossword-hidden-input')\n                            .setAttributeNS(null, 'aria-label', titleData);\n\n                    } else {\n                        el.classList.add('crossword-cell-highlighted');\n                    }\n                }\n            );\n    }\n\n    /**\n     * Replace string data.\n     *\n     * @param {String} str The string need to be replaced.\n     * @param {Object} data The data.\n     *\n     * @return {String} The replaced string.\n     */\n    replaceStringData(str, data) {\n        for (let key in data) {\n            str = str.replace(`{${key}}`, data[key]);\n        }\n        return str;\n    }\n\n    /**\n     * Sync data between clue section and crossword.\n     */\n    syncDataForInit() {\n        const {words} = this.options;\n        // Loop every input into clue section.\n        this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper').querySelectorAll('.wrap-clue input')\n            .forEach(element => {\n                // Tricky, update word number.\n                this.options.wordNumber = parseInt(element.closest('.wrap-clue').getAttribute('data-questionid'));\n                const word = words.find(o => o.number === this.options.wordNumber);\n                if (!word) {\n                    return;\n                }\n                // Sorting and Updating letter index.\n                this.updateLetterIndexForCells(word);\n                // The value will be filled into the valid cell.\n                this.syncLettersByText(element.value, false);\n            });\n        // Set wordNumber by default value.\n        this.options.wordNumber = -1;\n    }\n}\n"],"names":["constructor","options","answer","test","defaultOption","colsNum","rowsNum","words","target","isPreview","previewSetting","backgroundColor","borderColor","textColor","conflictColor","cellWidth","cellHeight","wordNumber","coordinates","targetEls","document","querySelectorAll","i","length","querySelector","crosswordEl","getColumnLabel","String","fromCharCode","charCodeAt","makeUnderscore","Array","from","join","updateLetterIndexForCells","word","this","letterList","letterListArray","prototype","slice","call","letterIndex","sort","a","b","aValue","parseInt","getAttributeNS","bValue","orientation","forEach","el","setAttributeNS","focusClue","containCrosswordEl","closest","clueEl","clueFocusEl","classList","remove","add","setStickyClue","stickyClue","find","o","number","strongEl","spanEl","createElement","append","innerText","clue","replaceText","value","replace","bindDataToClueInput","gEl","key","rectEl","conflictPointX","conflictPointY","match","wordId","startPoint","calculatePosition","y","x","clueInputEl","replaceAt","toUpperCase","startColumn","startRow","text","index","char","split","undefined","syncLettersByText","bindClue","letter","textEl","innerHTML","toggleHighlight","title","focus","focusedEl","titleData","data","row","column","count","replaceStringData","str","syncDataForInit","element","getAttribute"],"mappings":"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"}
>>>>>>> 82d645c (Support to use Chinese)
>>>>>>> 49a6e82 (Support to use Chinese)
