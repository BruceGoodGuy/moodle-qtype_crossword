{"version":3,"file":"crossword_question.min.js","sources":["../src/crossword_question.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * CrosswordQuestion base class handle every common function.\r\n *\r\n * @module qtype_crossword/crossword_question\r\n * @copyright 2022 The Open University\r\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nexport class CrosswordQuestion {\r\n\r\n    // Arrow Left key.\r\n    ARROW_LEFT = 'ArrowLeft';\r\n\r\n    // Arrow Right key.\r\n    ARROW_RIGHT = 'ArrowRight';\r\n\r\n    // Arrow Up key.\r\n    ARROW_UP = 'ArrowUp';\r\n\r\n    // Arrow Down key.\r\n    ARROW_DOWN = 'ArrowDown';\r\n\r\n    // End key.\r\n    END = 'End';\r\n\r\n    // Home key.\r\n    HOME = 'Home';\r\n\r\n    // Delete key.\r\n    DELETE = 'Delete';\r\n\r\n    // Backspace key.\r\n    BACKSPACE = 'Backspace';\r\n\r\n    // Z key.\r\n    Z_KEY = 'z';\r\n\r\n    // A key.\r\n    A_KEY = 'a';\r\n\r\n    // Enter key.\r\n    ENTER = 'Enter';\r\n\r\n    /**\r\n     * Constructor for crossword question.\r\n     *\r\n     * @param {Object} options The input options for the crossword.\r\n     */\r\n    constructor(options) {\r\n        let defaultOption = {\r\n            colsNum: 10,\r\n            rowsNum: 10,\r\n            words: [],\r\n            target: '#crossword',\r\n            isPreview: false,\r\n            previewSetting: {backgroundColor: '#ffffff', borderColor: '#000000', textColor: '#ffffff', conflictColor: '#f4cece'},\r\n            cellWidth: 31,\r\n            cellHeight: 31,\r\n            wordNumber: -1,\r\n            coordinates: ''\r\n        };\r\n        // Merge options.\r\n        defaultOption = {...defaultOption, ...options};\r\n        // Set options.\r\n        this.options = defaultOption;\r\n        // Get target element.\r\n        const targetEls = document.querySelectorAll(defaultOption.target);\r\n        for (let i = 0; i < targetEls.length; i++) {\r\n            if (!targetEls[i].querySelector('svg')) {\r\n                this.crosswordEl = targetEls[i];\r\n                this.options.crosswordEl = targetEls[i];\r\n                if (!this.options.isPreview) {\r\n                    this.options.words = this.retrieveWordData();\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get word data.\r\n     *\r\n     * @return {Array} Word data list.\r\n     */\r\n    retrieveWordData() {\r\n        const clueEls = this.options.crosswordEl\r\n            .closest('.qtype_crossword-grid-wrapper')\r\n            .querySelectorAll('.contain-clue .wrap-clue');\r\n        if (clueEls.length === 0) {\r\n            return [];\r\n        }\r\n        return [...clueEls].map(el => {\r\n            const number = parseInt(el.getAttribute('data-questionid'));\r\n            const startRow = parseInt(el.getAttribute('data-startrow'));\r\n            const startColumn = parseInt(el.getAttribute('data-startcolumn'));\r\n            const length = parseInt(el.getAttribute('data-length'));\r\n            const orientation = parseInt(el.getAttribute('data-orientation'));\r\n            const clue = el.getAttribute('data-clue');\r\n            return {number, startRow, startColumn, length, orientation, clue};\r\n        }).sort((clueA, clueB) => clueA.number - clueB.number);\r\n    }\r\n\r\n    /**\r\n     * Get alphabet character from position number.\r\n     *\r\n     * @param {Number} i Position character number.\r\n     * @return {String} Alphabet character.\r\n     */\r\n    getColumnLabel(i) {\r\n        return String.fromCharCode(\"A\".charCodeAt(0) + i - 1);\r\n    }\r\n\r\n    /**\r\n     * The answer must not contain any special character.\r\n     *\r\n     * @param {String} answer The answer string need to be check.\r\n     * @return {Boolean} The value data.\r\n     */\r\n    isInvalidAnswer = function(answer) {\r\n        return /[-@!$%^&*()_+|~=`\\\\#{}[\\]:\";'<>?,./]/gi.test(answer);\r\n    };\r\n\r\n    /**\r\n     * Generate underscore letter by length.\r\n     *\r\n     * @param {Number} length Expected length.\r\n     *\r\n     * @return {String} Underscore string.\r\n     */\r\n    makeUnderscore(length) {\r\n        const arr = Array.from({length}, () => '_');\r\n        return arr.join('');\r\n    }\r\n\r\n    /**\r\n     * Update the letter index of the word based on the word selected.\r\n     *\r\n     * @param {Object} word The word object.\r\n     */\r\n    updateLetterIndexForCells(word) {\r\n        const {wordNumber} = this.options;\r\n        const letterList = this.options.crosswordEl.querySelectorAll(`g[word*='(${wordNumber})']`);\r\n        // Convert letterList to array to use sort function.\r\n        const letterListArray = Array.prototype.slice.call(letterList, 0);\r\n        let letterIndex = 0;\r\n        // Rearrange the letters in the correct order.\r\n        letterListArray.sort((a, b) => {\r\n            let aValue = parseInt(a.querySelector('rect').getAttributeNS(null, 'x'));\r\n            let bValue = parseInt(b.querySelector('rect').getAttributeNS(null, 'x'));\r\n            if (word.orientation) {\r\n                aValue = parseInt(a.querySelector('rect').getAttributeNS(null, 'y'));\r\n                bValue = parseInt(b.querySelector('rect').getAttributeNS(null, 'y'));\r\n            }\r\n            return aValue - bValue;\r\n        }).forEach(el => {\r\n            // Update letter index.\r\n            el.setAttributeNS(null, 'letterIndex', letterIndex);\r\n            letterIndex++;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Toggle focus the clue.\r\n     */\r\n    focusClue() {\r\n        const {wordNumber} = this.options;\r\n        const containCrosswordEl = this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper');\r\n        const clueEl = containCrosswordEl.querySelector(`.wrap-clue[data-questionid='${wordNumber}']`);\r\n        const clueFocusEl = containCrosswordEl.querySelector(`.wrap-clue.focus`);\r\n        // Remove the current focus cell.\r\n        if (clueFocusEl) {\r\n            clueFocusEl.classList.remove('focus');\r\n        }\r\n        // Add focus cell.\r\n        if (clueEl) {\r\n            clueEl.classList.add('focus');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set sticky clue for the mobile version.\r\n     */\r\n    setStickyClue() {\r\n        const stickyClue = this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper').querySelector('.sticky-clue');\r\n        const {wordNumber, words} = this.options;\r\n        const word = words.find(o => o.number === parseInt(wordNumber));\r\n        if (!stickyClue && word) {\r\n            return;\r\n        }\r\n        let strongEl = stickyClue.querySelector('strong');\r\n        let spanEl = stickyClue.querySelector('span');\r\n        if (!strongEl) {\r\n            strongEl = document.createElement('strong');\r\n            strongEl.classList.add('mr-1');\r\n            stickyClue.append(strongEl);\r\n        }\r\n        if (!spanEl) {\r\n            spanEl = document.createElement('span');\r\n            stickyClue.append(spanEl);\r\n        }\r\n        strongEl.innerText = `${word.number} ${this.options.orientation[word.orientation]}`;\r\n        spanEl.innerText = `${word.clue} (${word.length})`;\r\n    }\r\n\r\n    /**\r\n     * Focus crossword cell from the start index.\r\n     *\r\n     * @param {String} value The value string need to be replaced.\r\n     * @return {String} The value data.\r\n     */\r\n    replaceText(value) {\r\n        return value.replace(/[-@!$%^&*()_+|~=`\\\\#{}[\\]:\";'<>?,./]/gi, '');\r\n    }\r\n\r\n    /**\r\n     * Bind data to the clue.\r\n     *\r\n     * @param {Element} gEl The word letter.\r\n     * @param {String} key The letter data.\r\n     */\r\n    bindDataToClueInput(gEl, key) {\r\n        const {words, cellWidth, cellHeight} = this.options;\r\n        const rectEl = gEl.querySelector('rect');\r\n        const conflictPointX = rectEl.getAttributeNS(null, 'x');\r\n        const conflictPointY = rectEl.getAttributeNS(null, 'y');\r\n        let letterIndex, value;\r\n        if (gEl) {\r\n            let wordIds = gEl.getAttributeNS(null, 'word').match(/\\d+/g);\r\n            wordIds.forEach(wordId => {\r\n                const word = words.find(o => o.number === parseInt(wordId));\r\n                if (word) {\r\n                    const startPoint = this.calculatePosition(word, 0);\r\n                    if (word.orientation) {\r\n                        letterIndex = (parseInt(conflictPointY) - startPoint.y) / (cellHeight + 1);\r\n                    } else {\r\n                        letterIndex = (parseInt(conflictPointX) - startPoint.x) / (cellWidth + 1);\r\n                    }\r\n                    const clueInputEl = this.options.crosswordEl\r\n                        .closest('.qtype_crossword-grid-wrapper')\r\n                        .querySelector(`.wrap-clue[data-questionid='${wordId}'] input`);\r\n                    value = this.replaceAt(clueInputEl.value, letterIndex, key);\r\n                    clueInputEl.value = value.toUpperCase();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate the position of each letter of the word.\r\n     *\r\n     * @param {Object} word The current word object.\r\n     * @param {Number} key The letter index of word.\r\n     *\r\n     * @return {Object} The coordinates of letter.\r\n     */\r\n    calculatePosition(word, key) {\r\n        const {cellWidth, cellHeight} = this.options;\r\n        let x = (cellWidth * word.startColumn) + (word.startColumn + 1);\r\n        let y = (cellHeight * word.startRow) + (word.startRow + 1);\r\n        if (word.orientation) {\r\n            y += (key * cellHeight) + key;\r\n        } else {\r\n            x += (key * cellWidth) + key;\r\n        }\r\n        return {x, y};\r\n    }\r\n\r\n    /**\r\n     * Replace letter at index.\r\n     *\r\n     * @param {String} text Text need to be replaced.\r\n     * @param {Number} index Letter index.\r\n     * @param {String} char The replace letter.\r\n     *\r\n     * @return {String} Underscore string.\r\n     */\r\n    replaceAt(text, index, char) {\r\n        let a = text.split('');\r\n        if (a[index] !== undefined) {\r\n            a[index] = char;\r\n        }\r\n        return a.join('');\r\n    }\r\n\r\n    /**\r\n     * Sync data to crossword cell from text.\r\n     *\r\n     * @param {Element} text The text data.\r\n     * @param {Boolean} [bindClue=false] Check if bind data into clue.\r\n     */\r\n    syncLettersByText(text, bindClue = true) {\r\n        const {wordNumber} = this.options;\r\n        for (let i in text) {\r\n            const gEl = this.options.crosswordEl.querySelector(`g[word*='(${wordNumber})'][letterIndex='${i}']`);\r\n            if (gEl) {\r\n                const letter = text[i].toUpperCase();\r\n                const textEl = gEl.querySelector('text.crossword-cell-text');\r\n                if (text[i] !== '_') {\r\n                    textEl.innerHTML = letter;\r\n                } else {\r\n                    textEl.innerHTML = '';\r\n                }\r\n                if (bindClue) {\r\n                    this.bindDataToClueInput(gEl, letter);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggle the highlight cells.\r\n     *\r\n     * @param {Object} word The word object.\r\n     * @param {Element} gEl The g element.\r\n     */\r\n    toggleHighlight(word, gEl) {\r\n        const {wordNumber, orientation, title} = this.options;\r\n        const focus = wordNumber;\r\n        const focusedEl = this.options.crosswordEl.querySelector('.crossword-cell-focussed');\r\n        if (focusedEl) {\r\n            focusedEl.classList.remove('crossword-cell-focussed');\r\n        }\r\n        // Remove current highlight cells.\r\n        this.options.crosswordEl.querySelectorAll('.crossword-cell-highlighted')\r\n            .forEach(el => el.classList.remove('crossword-cell-highlighted'));\r\n        // Set highlight cells.\r\n        this.options.crosswordEl.querySelectorAll(`g[word*='(${focus})'] rect`)\r\n            .forEach(el => {\r\n                    let titleData = '';\r\n                    if (el.closest('g').getAttributeNS(null, 'code') === gEl.getAttributeNS(null, 'code')) {\r\n                        el.classList.add('crossword-cell-focussed');\r\n                        // Update aria label.\r\n                        let letterIndex = parseInt(el.closest('g').getAttributeNS(null, 'letterIndex'));\r\n                        const data = {\r\n                            row: word.startRow + 1,\r\n                            column: word.startColumn + letterIndex + 1,\r\n                            number: word.number,\r\n                            orientation: orientation[word.orientation],\r\n                            clue: word.clue,\r\n                            letter: letterIndex + 1,\r\n                            count: word.length\r\n                        };\r\n                        if (word.orientation) {\r\n                            data.row = word.startRow + letterIndex + 1;\r\n                            data.column = word.startColumn + 1;\r\n                        }\r\n                        titleData = this.replaceStringData(title, data);\r\n                        this.options.crosswordEl.querySelector('input.crossword-hidden-input')\r\n                            .setAttributeNS(null, 'aria-label', titleData);\r\n\r\n                    } else {\r\n                        el.classList.add('crossword-cell-highlighted');\r\n                    }\r\n                }\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Replace string data.\r\n     *\r\n     * @param {String} str The string need to be replaced.\r\n     * @param {Object} data The data.\r\n     *\r\n     * @return {String} The replaced string.\r\n     */\r\n    replaceStringData(str, data) {\r\n        for (let key in data) {\r\n            str = str.replace(`{${key}}`, data[key]);\r\n        }\r\n        return str;\r\n    }\r\n\r\n    /**\r\n     * Sync data between clue section and crossword.\r\n     */\r\n    syncDataForInit() {\r\n        const {words} = this.options;\r\n        // Loop every input into clue section.\r\n        this.options.crosswordEl.closest('.qtype_crossword-grid-wrapper').querySelectorAll('.wrap-clue input')\r\n            .forEach(element => {\r\n                // Tricky, update word number.\r\n                this.options.wordNumber = parseInt(element.closest('.wrap-clue').getAttribute('data-questionid'));\r\n                const word = words.find(o => o.number === this.options.wordNumber);\r\n                if (!word) {\r\n                    return;\r\n                }\r\n                // Sorting and Updating letter index.\r\n                this.updateLetterIndexForCells(word);\r\n                // The value will be filled into the valid cell.\r\n                this.syncLettersByText(element.value, false);\r\n            });\r\n        // Set wordNumber by default value.\r\n        this.options.wordNumber = -1;\r\n    }\r\n}\r\n"],"names":["constructor","options","answer","test","defaultOption","colsNum","rowsNum","words","target","isPreview","previewSetting","backgroundColor","borderColor","textColor","conflictColor","cellWidth","cellHeight","wordNumber","coordinates","targetEls","document","querySelectorAll","i","length","querySelector","crosswordEl","this","retrieveWordData","clueEls","closest","map","el","number","parseInt","getAttribute","startRow","startColumn","orientation","clue","sort","clueA","clueB","getColumnLabel","String","fromCharCode","charCodeAt","makeUnderscore","Array","from","join","updateLetterIndexForCells","word","letterList","letterListArray","prototype","slice","call","letterIndex","a","b","aValue","getAttributeNS","bValue","forEach","setAttributeNS","focusClue","containCrosswordEl","clueEl","clueFocusEl","classList","remove","add","setStickyClue","stickyClue","find","o","strongEl","spanEl","createElement","append","innerText","replaceText","value","replace","bindDataToClueInput","gEl","key","rectEl","conflictPointX","conflictPointY","match","wordId","startPoint","calculatePosition","y","x","clueInputEl","replaceAt","toUpperCase","text","index","char","split","undefined","syncLettersByText","bindClue","letter","textEl","innerHTML","toggleHighlight","title","focus","focusedEl","titleData","data","row","column","count","replaceStringData","str","syncDataForInit","element"],"mappings":"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"}