{"version":3,"file":"crossword_clue.min.js","sources":["../src/crossword_clue.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Crossword clue class, handle any action relative to clue.\r\n *\r\n * @module qtype_crossword/crossword_clue\r\n * @copyright 2022 The Open University\r\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport {CrosswordQuestion} from 'qtype_crossword/crossword_question';\r\n\r\nexport class CrosswordClue extends CrosswordQuestion {\r\n\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param {Object} options The settings for crossword.\r\n     */\r\n    constructor(options) {\r\n        super(options);\r\n    }\r\n\r\n    /**\r\n     * Set up for clue section.\r\n     */\r\n    setUpClue() {\r\n        let {words, readonly} = this.options;\r\n        const clueEls = this.options.crosswordEl\r\n            .closest('.qtype_crossword-grid-wrapper')\r\n            .querySelectorAll('.contain-clue .wrap-clue');\r\n        clueEls.forEach(el => {\r\n            const questionId = el.dataset.questionid;\r\n            let word = words.find(o => o.number === parseInt(questionId));\r\n            if (word) {\r\n                const inputEl = el.querySelector('input');\r\n                // Retrieve special characters list.\r\n                const ignoreIndexes = this.getIgnoreIndexByAnswerNumber(word.number, false);\r\n                const wordString = this.makeUnderscore(word.length - inputEl.value.length);\r\n                // Add special characters to the answer, then set it to the answer input.\r\n                inputEl.value += this.mapAnswerAndSpecialLetter(wordString, ignoreIndexes[0]);\r\n                if (!readonly) {\r\n                    inputEl.disabled = false;\r\n                }\r\n                // Add event for input.\r\n                this.addEventForClueInput(inputEl, word);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add event to word input element.\r\n     *\r\n     * @param {Element} el The input element.\r\n     * @param {String} word The word data.\r\n     */\r\n    addEventForClueInput(el, word) {\r\n        const {readonly} = this.options;\r\n        let startSelection = 0;\r\n        if (readonly) {\r\n            return;\r\n        }\r\n        el.addEventListener('click', (e) => {\r\n            const {words} = this.options;\r\n            const wordNumber = e.target.closest('.wrap-clue').dataset.questionid;\r\n            const wordObj = words.find(o => o.number === parseInt(wordNumber));\r\n            let startIndex = e.target.selectionStart;\r\n            if (startIndex >= word.length) {\r\n                startIndex = word.length - 1;\r\n            }\r\n            // Based on the selected letter index on the answer index,\r\n            // we will find the corresponding crossword cell index.\r\n            startIndex = this.findCellIndexFromAnswerIndex(wordObj, startIndex);\r\n            this.focusCellByStartIndex(startIndex, word);\r\n            this.focusClue();\r\n            this.setStickyClue();\r\n        });\r\n\r\n        el.addEventListener('focus', (e) => {\r\n            e.target.dispatchEvent(new Event('click'));\r\n        });\r\n        el.addEventListener('beforeinput', (e) => {\r\n            if (e.inputType === 'insertText' && e.data) {\r\n                this.handleInsertedCharacterToElement(e, e.data);\r\n            }\r\n        });\r\n\r\n        el.addEventListener('input', (e) => {\r\n            if (e.inputType === 'deleteContentBackward') {\r\n                this.handleAndSyncDeletedStringToElement(e.target, e.target.value);\r\n            }\r\n        });\r\n\r\n        el.addEventListener('keypress', (e) => {\r\n            e.preventDefault();\r\n            this.handleInsertedCharacterToElement(e, e.key);\r\n        });\r\n\r\n        el.addEventListener('compositionstart', (evt) => {\r\n            const selection = evt.target.selectionStart;\r\n            startSelection = selection;\r\n        });\r\n\r\n        el.addEventListener('compositionend', (evt) => {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n            const {wordNumber} = this.options;\r\n            const selection = evt.target.selectionStart;\r\n            let key = evt.data.normalize('NFKC');\r\n            let currentSelection = startSelection;\r\n            evt.target.setSelectionRange(selection, selection);\r\n            key.split('').forEach(char => {\r\n                const result = this.handleTypingData(evt, wordNumber, word, currentSelection, char);\r\n                if (result) {\r\n                    currentSelection++;\r\n                }\r\n            });\r\n        });\r\n\r\n        el.addEventListener('keyup', (event) => {\r\n            event.preventDefault();\r\n            const {words, wordNumber} = this.options;\r\n            const {key, target} = event;\r\n            let {value} = target;\r\n            let isValidKey = false;\r\n            let maxLength = parseInt(target.getAttribute('maxlength'));\r\n            if ([this.ARROW_LEFT, this.ARROW_RIGHT].includes(key)) {\r\n                isValidKey = true;\r\n                const word = words.find(o => o.number === parseInt(wordNumber));\r\n                // Based on the selected letter index of the answer input,\r\n                // we will find the cell with the corresponding letter index attribute.\r\n                const startIndex = this.findCellIndexFromAnswerIndex(word, target.selectionStart, false);\r\n                const gEl = this.options.crosswordEl\r\n                    .querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${startIndex}']`);\r\n                if (gEl) {\r\n                    this.toggleHighlight(word, gEl);\r\n                }\r\n            }\r\n            if (key === this.DELETE || key === this.BACKSPACE) {\r\n                this.handleAndSyncDeletedStringToElement(target, value);\r\n            }\r\n\r\n            if (key === this.END || key === this.HOME || key === this.ARROW_UP || key === this.ARROW_DOWN) {\r\n                isValidKey = true;\r\n                let startIndex = 0;\r\n                const word = words.find(o => o.number === parseInt(wordNumber));\r\n                if (!word) {\r\n                    return;\r\n                }\r\n                if (key === this.END || key === this.ARROW_DOWN) {\r\n                    startIndex = word.length - 1;\r\n                }\r\n                this.syncFocusCellAndInput(target, startIndex);\r\n            }\r\n\r\n            if (!isValidKey && startSelection >= maxLength) {\r\n                event.target.value = value.slice(0, maxLength);\r\n            }\r\n        });\r\n\r\n        el.addEventListener('paste', (event) => {\r\n            event.preventDefault();\r\n            const {words, wordNumber} = this.options;\r\n            const word = words.find(o => o.number === parseInt(wordNumber));\r\n            let selection = event.target.selectionStart;\r\n            let value = (event.clipboardData || window.clipboardData).getData('text');\r\n            let ignoreIndexes = this.getIgnoreIndexByAnswerNumber(word.number);\r\n            // Remove invalid characters, normarlize NFKC.\r\n            value = this.replaceText(value).normalize('NFKC');\r\n            if (value === '') {\r\n                return;\r\n            }\r\n            let letterIndex = 1;\r\n            value.split('').every(char => {\r\n                // Stop function If the character overflows.\r\n                if (letterIndex > word.length - ignoreIndexes.length) {\r\n                    return false;\r\n                }\r\n                const result = this.handleTypingData(event, wordNumber, word, selection, char);\r\n                letterIndex++;\r\n                // Find the valid index.\r\n                if (result) {\r\n                    for (let index = selection + 1; index < word.length; index++) {\r\n                        if (!ignoreIndexes.includes(index)) {\r\n                            selection = index;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            });\r\n        });\r\n\r\n        el.addEventListener('keydown', (e) => {\r\n            if (e.ctrlKey && e.key.toLowerCase() === this.Z_KEY) {\r\n                e.preventDefault();\r\n            }\r\n            if (e.key === this.ENTER) {\r\n                e.preventDefault();\r\n            }\r\n        });\r\n\r\n        el.addEventListener('cut', (event) => {\r\n            const selectString = document.getSelection().toString();\r\n            const startIndex = event.target.selectionStart;\r\n            let {value} = event.target;\r\n            value = value.substring(0, startIndex) +\r\n                value.substring(startIndex + selectString.length) +\r\n                this.makeUnderscore(selectString.length);\r\n            event.target.value = value;\r\n            event.clipboardData.setData('text/plain', selectString);\r\n            event.preventDefault();\r\n            event.target.setSelectionRange(startIndex, startIndex);\r\n            // In case the user cuts off the entire answer, we need to update the crossword grid.\r\n            this.syncLettersByText(value, false);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle typing data.\r\n     *\r\n     * @param {Object} evt Event data.\r\n     * @param {Number} wordNumber The word number.\r\n     * @param {Object} word The word object.\r\n     * @param {Number} selectionIndex The position of cursor selection.\r\n     * @param {String} char The character.\r\n     *\r\n     * @return {Boolean} True if the data is valid.\r\n     */\r\n    handleTypingData(evt, wordNumber, word, selectionIndex, char) {\r\n        const [count, gEl] = this.findTheClosestCell(wordNumber, word, selectionIndex);\r\n        if (this.replaceText(char) === '') {\r\n            return false;\r\n        }\r\n        if (gEl) {\r\n            gEl.querySelector('text.crossword-cell-text').innerHTML = char.toUpperCase();\r\n            this.bindDataToClueInput(gEl, char.toUpperCase());\r\n        }\r\n\r\n        // Go to next letter.\r\n        const [letterIndex, nexEl] = this.findTheClosestCell(wordNumber, word, count + 1);\r\n        if (nexEl) {\r\n            this.toggleHighlight(word, nexEl);\r\n            evt.target.setSelectionRange(letterIndex, letterIndex);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Focus cell base on the start index.\r\n     *\r\n     * @param {Element} startIndex The start index.\r\n     * @param {String} word The word data.\r\n     */\r\n    focusCellByStartIndex(startIndex, word) {\r\n        let position = this.calculatePosition(word, startIndex);\r\n        const rect = this.options.crosswordEl.querySelector(`g rect[x='${position.x}'][y='${position.y}']`);\r\n        if (rect) {\r\n            this.options.wordNumber = word.number;\r\n            this.toggleHighlight(word, rect.closest('g'));\r\n            this.updateLetterIndexForCells(word);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Focus crossword cell from the start index.\r\n     *\r\n     * @param {Element} target The element.\r\n     * @param {Number} startIndex The start index.\r\n     */\r\n    syncFocusCellAndInput(target, startIndex) {\r\n        const {wordNumber} = this.options;\r\n        const gEl = this.options.crosswordEl.querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${startIndex}']`);\r\n        target.setSelectionRange(startIndex, startIndex);\r\n        if (gEl) {\r\n            this.toggleFocus(gEl);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggle the focus cell.\r\n     *\r\n     * @param {Element} gEl The word letter.\r\n     */\r\n    toggleFocus(gEl) {\r\n        const focused = this.options.crosswordEl.querySelector('g rect.crossword-cell-focussed');\r\n        if (focused) {\r\n            focused.classList.remove('crossword-cell-focussed');\r\n            focused.classList.add('crossword-cell-highlighted');\r\n        }\r\n        gEl.querySelector('rect').classList.add('crossword-cell-focussed');\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Add underscore to deleted string and sync it to crossword clue input.\r\n     *\r\n     * @param {Element} target The element target\r\n     * @param {String} value the string input after we deleted single or multiples character.\r\n     */\r\n    handleAndSyncDeletedStringToElement(target, value) {\r\n        const {words, wordNumber} = this.options;\r\n        const word = words.find(o => o.number === parseInt(wordNumber));\r\n        if (!word) {\r\n            return;\r\n        }\r\n        let startIndex = target.selectionStart;\r\n        const selectionLength = word.length - value.length;\r\n        const underScore = this.makeUnderscore(selectionLength);\r\n        // Insert underscore to deleted string.\r\n        target.value = [value.slice(0, startIndex), underScore, value.slice(startIndex)].join('');\r\n        // In case the user deletes the entire answer we need to update the crossword grid.\r\n        this.syncLettersByText(target.value, false);\r\n        this.syncFocusCellAndInput(target, startIndex);\r\n    }\r\n\r\n    /**\r\n     * Insert the character to clue input.\r\n     *\r\n     * @param {Object} event Event data.\r\n     * @param {String} value the character we are inserted to the clue input.\r\n     */\r\n    handleInsertedCharacterToElement(event, value) {\r\n        const {words, wordNumber} = this.options;\r\n        const word = words.find(o => o.number === parseInt(wordNumber));\r\n        let startIndex = event.target.selectionStart;\r\n        value = this.replaceText(value).normalize('NFKC');\r\n        if (value === '') {\r\n            return;\r\n        }\r\n        this.handleTypingData(event, wordNumber, word, startIndex, value);\r\n    }\r\n}\r\n"],"names":["CrosswordClue","CrosswordQuestion","constructor","options","setUpClue","words","readonly","this","crosswordEl","closest","querySelectorAll","forEach","el","questionId","dataset","questionid","word","find","o","number","parseInt","inputEl","querySelector","ignoreIndexes","getIgnoreIndexByAnswerNumber","wordString","makeUnderscore","length","value","mapAnswerAndSpecialLetter","disabled","addEventForClueInput","startSelection","addEventListener","e","wordNumber","target","wordObj","startIndex","selectionStart","findCellIndexFromAnswerIndex","focusCellByStartIndex","focusClue","setStickyClue","dispatchEvent","Event","inputType","data","handleInsertedCharacterToElement","handleAndSyncDeletedStringToElement","preventDefault","key","evt","selection","stopPropagation","normalize","currentSelection","setSelectionRange","split","char","handleTypingData","event","isValidKey","maxLength","getAttribute","ARROW_LEFT","ARROW_RIGHT","includes","gEl","toggleHighlight","DELETE","BACKSPACE","END","HOME","ARROW_UP","ARROW_DOWN","syncFocusCellAndInput","slice","clipboardData","window","getData","replaceText","letterIndex","every","result","index","ctrlKey","toLowerCase","Z_KEY","ENTER","selectString","document","getSelection","toString","substring","setData","syncLettersByText","selectionIndex","count","findTheClosestCell","innerHTML","toUpperCase","bindDataToClueInput","nexEl","position","calculatePosition","rect","x","y","updateLetterIndexForCells","toggleFocus","focused","classList","remove","add","selectionLength","underScore","join"],"mappings":"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"}