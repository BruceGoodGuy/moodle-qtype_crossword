{"version":3,"file":"crossword_clue.min.js","sources":["../src/crossword_clue.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Crossword clue class, handle any action relative to clue.\r\n *\r\n * @module qtype_crossword/crossword_clue\r\n * @copyright 2022 The Open University\r\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport {CrosswordQuestion} from 'qtype_crossword/crossword_question';\r\n\r\nexport class CrosswordClue extends CrosswordQuestion {\r\n\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param {Object} options The settings for crossword.\r\n     */\r\n    constructor(options) {\r\n        super(options);\r\n    }\r\n\r\n    /**\r\n     * Set up for clue section.\r\n     */\r\n    setUpClue() {\r\n        let {words, readonly} = this.options;\r\n        const clueEls = this.options.crosswordEl\r\n            .closest('.qtype_crossword-grid-wrapper')\r\n            .querySelectorAll('.contain-clue .wrap-clue');\r\n        clueEls.forEach(el => {\r\n            const questionId = el.dataset.questionid;\r\n            let word = words.find(o => o.number === parseInt(questionId));\r\n            if (word) {\r\n                const inputEl = el.querySelector('input');\r\n                inputEl.value += this.makeUnderscore(word.length - inputEl.value.length);\r\n                if (!readonly) {\r\n                    inputEl.disabled = false;\r\n                }\r\n                // Add event for input.\r\n                this.addEventForClueInput(inputEl, word);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add event to word input element.\r\n     *\r\n     * @param {Element} el The input element.\r\n     * @param {String} word The word data.\r\n     */\r\n    addEventForClueInput(el, word) {\r\n        const {readonly} = this.options;\r\n        let startSelection = 0;\r\n        if (readonly) {\r\n            return;\r\n        }\r\n        el.addEventListener('click', (e) => {\r\n            let startIndex = e.target.selectionStart;\r\n            if (startIndex >= word.length) {\r\n                startIndex = word.length - 1;\r\n            }\r\n            this.focusCellByStartIndex(startIndex, word);\r\n            this.focusClue();\r\n            this.setStickyClue();\r\n        });\r\n\r\n        el.addEventListener('focus', (e) => {\r\n            e.target.dispatchEvent(new Event('click'));\r\n        });\r\n\r\n        el.addEventListener('beforeinput', (e) => {\r\n            e.preventDefault();\r\n            const {words, wordNumber} = this.options;\r\n            const word = words.find(o => o.number === parseInt(wordNumber));\r\n            let {data, target} = e;\r\n            let startIndex = target.selectionStart;\r\n            data = this.replaceText(data).normalize('NFKC');\r\n            if (data === '') {\r\n                return;\r\n            }\r\n            this.handleTypingData(e, wordNumber, word, startIndex, data);\r\n        });\r\n\r\n        el.addEventListener('compositionstart', (evt) => {\r\n            const selection = evt.target.selectionStart;\r\n            startSelection = selection;\r\n        });\r\n\r\n        el.addEventListener('compositionend', (evt) => {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n            const {wordNumber} = this.options;\r\n            const selection = evt.target.selectionStart;\r\n            let key = evt.data.normalize('NFKC');\r\n            let currentSelection = startSelection;\r\n            evt.target.setSelectionRange(selection, selection);\r\n            key.split('').forEach(char => {\r\n                const result = this.handleTypingData(evt, wordNumber, word, currentSelection, char);\r\n                if (result) {\r\n                    currentSelection++;\r\n                }\r\n            });\r\n        });\r\n\r\n        el.addEventListener('keyup', (event) => {\r\n            event.preventDefault();\r\n            const {words, wordNumber} = this.options;\r\n            const {key, target} = event;\r\n            let {value} = target;\r\n            let isValidKey = false;\r\n            let maxLength = parseInt(target.getAttribute('maxlength'));\r\n            if ([this.ARROW_LEFT, this.ARROW_RIGHT].includes(key)) {\r\n                isValidKey = true;\r\n                const startIndex = target.selectionStart;\r\n                const gEl = this.options.crosswordEl\r\n                        .querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${startIndex}']`);\r\n                if (gEl) {\r\n                    this.toggleHighlight(word, gEl);\r\n                }\r\n            }\r\n            if (key === this.DELETE || key === this.BACKSPACE) {\r\n                isValidKey = true;\r\n                const word = words.find(o => o.number === parseInt(wordNumber));\r\n                let startIndex = target.selectionStart;\r\n                if (!word) {\r\n                    return;\r\n                }\r\n                const selectionLength = word.length - value.length;\r\n                const underScore = this.makeUnderscore(selectionLength);\r\n                value = [value.slice(0, startIndex), underScore, value.slice(startIndex)].join('');\r\n                target.value = value;\r\n                // In case the user deletes the entire answer we need to update the crossword grid.\r\n                this.syncLettersByText(value, false);\r\n                this.syncFocusCellAndInput(target, startIndex);\r\n            }\r\n\r\n            if (key === this.END || key === this.HOME) {\r\n                isValidKey = true;\r\n                let startIndex = 0;\r\n                const word = words.find(o => o.number === parseInt(wordNumber));\r\n                if (!word) {\r\n                    return;\r\n                }\r\n                if (key === this.END) {\r\n                    startIndex = word.length - 1;\r\n                }\r\n                this.syncFocusCellAndInput(target, startIndex);\r\n            }\r\n\r\n            if (!isValidKey && startSelection >= maxLength) {\r\n                event.target.value = value.slice(0, maxLength);\r\n            }\r\n        });\r\n\r\n        el.addEventListener('paste', (event) => {\r\n            event.preventDefault();\r\n            const {words, wordNumber} = this.options;\r\n            const word = words.find(o => o.number === parseInt(wordNumber));\r\n            let selection = event.target.selectionStart;\r\n            let value = (event.clipboardData || window.clipboardData).getData('text');\r\n            value = this.replaceText(value).normalize('NFKC');\r\n            if (value === \"\") {\r\n                return;\r\n            }\r\n            value.split('').forEach(char => {\r\n                const result = this.handleTypingData(event, wordNumber, word, selection, char);\r\n                if (result) {\r\n                    selection++;\r\n                }\r\n            });\r\n        });\r\n\r\n        el.addEventListener('keydown', (e) => {\r\n            if (e.ctrlKey && e.key.toLowerCase() === this.Z_KEY) {\r\n                e.preventDefault();\r\n            }\r\n            if (e.key === this.ENTER) {\r\n                e.preventDefault();\r\n            }\r\n        });\r\n\r\n        el.addEventListener('cut', (event) => {\r\n            const selectString = document.getSelection().toString();\r\n            const startIndex = event.target.selectionStart;\r\n            let {value} = event.target;\r\n            value = value.substring(0, startIndex) +\r\n                value.substring(startIndex + selectString.length) +\r\n                this.makeUnderscore(selectString.length);\r\n            event.target.value = value;\r\n            event.clipboardData.setData('text/plain', selectString);\r\n            event.preventDefault();\r\n            event.target.setSelectionRange(startIndex, startIndex);\r\n            // In case the user cuts off the entire answer, we need to update the crossword grid.\r\n            this.syncLettersByText(value, false);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle typing data.\r\n     *\r\n     * @param {Object} evt Event data.\r\n     * @param {Number} wordNumber The word number.\r\n     * @param {Object} word The word object.\r\n     * @param {Number} selectionIndex The position of cursor selection.\r\n     * @param {String} char The character.\r\n     *\r\n     * @return {Boolean} True if the data is valid.\r\n     */\r\n    handleTypingData(evt, wordNumber, word, selectionIndex, char) {\r\n        const gelEl = this.options.crosswordEl\r\n            .querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${selectionIndex}']`);\r\n        if (this.replaceText(char) === '') {\r\n            return false;\r\n        }\r\n        if (gelEl) {\r\n            gelEl.querySelector('text.crossword-cell-text').innerHTML = char.toUpperCase();\r\n            this.bindDataToClueInput(gelEl, char.toUpperCase());\r\n        }\r\n        selectionIndex++;\r\n\r\n        // Go to next letter.\r\n        const nexEl = this.options.crosswordEl\r\n            .querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${selectionIndex}']`);\r\n        if (nexEl) {\r\n            this.toggleHighlight(word, nexEl);\r\n            evt.target.setSelectionRange(selectionIndex, selectionIndex);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Focus cell base on the start index.\r\n     *\r\n     * @param {Element} startIndex The start index.\r\n     * @param {String} word The word data.\r\n     */\r\n    focusCellByStartIndex(startIndex, word) {\r\n        let position = this.calculatePosition(word, startIndex);\r\n        const rect = this.options.crosswordEl.querySelector(`g rect[x='${position.x}'][y='${position.y}']`);\r\n        if (rect) {\r\n            this.options.wordNumber = word.number;\r\n            this.toggleHighlight(word, rect.closest('g'));\r\n            this.updateLetterIndexForCells(word);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Focus crossword cell from the start index.\r\n     *\r\n     * @param {Element} target The element.\r\n     * @param {Number} startIndex The start index.\r\n     */\r\n    syncFocusCellAndInput(target, startIndex) {\r\n        const {wordNumber} = this.options;\r\n        const gEl = this.options.crosswordEl.querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${startIndex}']`);\r\n        target.setSelectionRange(startIndex, startIndex);\r\n        if (gEl) {\r\n            this.toggleFocus(gEl);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggle the focus cell.\r\n     *\r\n     * @param {Element} gEl The word letter.\r\n     */\r\n    toggleFocus(gEl) {\r\n        const focused = this.options.crosswordEl.querySelector('g rect.crossword-cell-focussed');\r\n        if (focused) {\r\n            focused.classList.remove('crossword-cell-focussed');\r\n            focused.classList.add('crossword-cell-highlighted');\r\n        }\r\n        gEl.querySelector('rect').classList.add('crossword-cell-focussed');\r\n    }\r\n}\r\n"],"names":["CrosswordClue","CrosswordQuestion","constructor","options","setUpClue","words","readonly","this","crosswordEl","closest","querySelectorAll","forEach","el","questionId","dataset","questionid","word","find","o","number","parseInt","inputEl","querySelector","value","makeUnderscore","length","disabled","addEventForClueInput","startSelection","addEventListener","e","startIndex","target","selectionStart","focusCellByStartIndex","focusClue","setStickyClue","dispatchEvent","Event","preventDefault","wordNumber","data","replaceText","normalize","handleTypingData","evt","selection","stopPropagation","key","currentSelection","setSelectionRange","split","char","event","isValidKey","maxLength","getAttribute","ARROW_LEFT","ARROW_RIGHT","includes","gEl","toggleHighlight","DELETE","BACKSPACE","selectionLength","underScore","slice","join","syncLettersByText","syncFocusCellAndInput","END","HOME","clipboardData","window","getData","ctrlKey","toLowerCase","Z_KEY","ENTER","selectString","document","getSelection","toString","substring","setData","selectionIndex","gelEl","innerHTML","toUpperCase","bindDataToClueInput","nexEl","position","calculatePosition","rect","x","y","updateLetterIndexForCells","toggleFocus","focused","classList","remove","add"],"mappings":"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"}